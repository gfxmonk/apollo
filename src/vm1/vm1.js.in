/*
 * VM1 Stratified JavaScript Virtual Machine 
 *
 * Part of Oni Apollo
 * http://onilabs.com/apollo
 *
 * (c) 2011 Oni Labs, http://onilabs.com
 *
 * This file is licensed under the terms of the GPL v2, see
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

/*
Preprocessor flags:

#define CLIENTSIDE    : for browser-based VM (as opposed to rocket-hosted)
#define NODEJS        : for nodejs VM (as opposed to rocket/clientside)

#define DEBUG_VM      : VM debugging

#define HOTPATH       : don't build execution frames unless we have to

OBSOLETE FLAGS:
    verbose exceptions are always on now; not predicated on this flag anymore:
#define VERBOSE_EXCEPTIONS : add line/file/stack members to exceptions
                             (requires compiling c1 with VERBOSE_EXCEPTIONS to
                              get correct values)
                             XXX We should actually only amend Error objects
                             where they are *created*. This code is possibly a
                             bit flaky with exceptions that are thrown by
                             JS code and caught/rethrown by SJS.


    we really don't want async resume:
#define ASYNC_RESUME  : obsolete asynchronous resume code path

*/
/* #define DEBUG_VM 1 */
#ifdef DEBUG_VM
#define EF_TYPES
#define LOG(x) console.log(x);
// XXX figure out why normal CPP stringification is screwed
#define ASSERT(X) if(!(X)) { throw new Error("Assertion failed: " + "X" ); }
#define WHENDEBUG(X) X
#else
#define ASSERT(X)
#define LOG(x)
#define WHENDEBUG(X)
#endif

// we don't want to rely on the global 'undefined' symbol; see
// https://groups.google.com/d/msg/oni-apollo/fNMz2W8S5mU/sYCgrriYj1MJ
var UNDEF; // == undefined

// on firefox this seems to help, on v8 it doesn't :-/
//#define HOTPATH 1

//----------------------------------------------------------------------
// Control Flow Exceptions

/*
{
  __oni_cfx: true,
  type:      "i"(internal)|"r"(return)|"b"(break)|"c"(continue)|"t"(thrown),
  val:       value
}
*/

//#define is_cfx(obj) (obj && obj.__oni_cfx)
#define is_cfx(obj) (obj instanceof CFException)
/*function is_cfx(obj) {
  return obj && obj.__oni_cfx;
}*/

function augmented_message(e) {
  return e.message+" (in "+e.file+(e.line ? ":"+e.line : "")+")";
}

function CFException_toString() {
  return this.name+": "+augmented_message(this);
}

function adopt_native_stack(e) {
  if(!e.stack) {
    e.stack = "";
    return;
  }
  if (e.__oni_stack) return;
  var stack = String(e.stack);
  LOG("ADOPTING new stack: " + stack);
  e.stack = "";
  var lines = stack.split("\n");
  var i;
  for (i=0; i<lines.length; i++) {
    // TODO: make this check more reliable (and xbrowser):
    if(lines[i].indexOf("oni-apollo-node.js") != -1) {
      // we've hit an apollo stack line.
      break;
    }
  }
  i--;
  var oni_stack = [];
  while(i >= 0) {
    oni_stack.unshift([lines[i]])
    i--;
  }
  // LOG("ADOPTED new stack: " + oni_stack.join("\n - "));
  e.__oni_stack = oni_stack;
}

var token_oniE = {}; // oni-modified exception
function CFException(type, value, line, file) {
  this.type = type;
  // XXX checking for "value instanceof Error" alone doesn't work for some errors on firefox
  if (type == "t" && (value instanceof Error || (typeof value == "object" && value.message)) && value._oniE !== token_oniE) {
    value._oniE = token_oniE;
    value.line = line;
    value.file = file || "unknown SJS source";
    adopt_native_stack(value);
    if (!value.hasOwnProperty('toString'))
      value.toString = CFException_toString;    
  }
  this.val = value;
  // this.ef = UNDEF;  // 'execution frame' tag for targetted return/break/continue
}
exports.CFER = function(env, value) { 
  var e = new CFException('r', value);
  if (env.ref) {
    // we're returning to a lexical function container (usually from blocklambdas)
    if (env.ref.unreturnable) // the function is not active anymore!
      throw new TypeError(e.toString());
    //WHENDEBUG(console.log('tagged return!!');)
    e.ef = env.ref;
  }
  return e;
}

var CFETypes = { r:"return", b:"break", c:"continue"};
CFException.prototype = {
  __oni_cfx : true,
  toString : function() {
    if (this.type in CFETypes)
      return "Unexpected "+CFETypes[this.type]+" statement";
    else
      return "Uncaught internal SJS control flow exception ("+this.type+":: "+this.val+")";
  },
  mapToJS : function(augment_mes, file, lineno) {
    if (this.type == "t") {
      annotate_exception_stack(this, file, lineno, 'mapToJS');
      var e = (augment_mes && this.val.file) ? new Error(augmented_message(this.val)) : this.val;
      throw e;
    }
    else if (!this.ef)
      throw new Error(this.toString());
    else // this is a 'b', 'c' or 'r' tunneling through a JS functions:
      throw this;
  }
};


//----------------------------------------------------------------------
// Execution Frames

function is_ef(obj) {
  return obj && obj.__oni_ef;
}

function setEFProto(t) { for (var p in EF_Proto) t[p] = EF_Proto[p]; }
//function setEFProto(t) { t.__proto__ = EF_Proto; }


// base prototype object for execution frames
var EF_Proto = {
#ifdef EF_TYPES
  toString: function() { return "<SJS Execution Frame '"+this.type+"'>"; },
#else
  toString: function() { return "<suspended SJS>"; },
#endif
  __oni_ef : true,
  lineno: function() {
    if(this.child_frame && this.child_frame.lineno)
    {
      // TODO: is this ever used?
      LOG("EF_Proto Using child_frame's lineno() function");
      return this.child_frame.lineno();
    }
    LOG("no lineno for " + this + " // " + this.type);
    //throw new Error("no lineno function for " + this + " // " + this.type)
    return null;
  },

  setChildFrame: function(ef, idx) {
    this.async = true;
    this.child_frame = ef;
    ef.parent = this;
    ef.parent_idx = idx;
  },

  // quench reentrant resume calls.
  // This signal is issued before abort() calls, to prevent any resume() calls in our
  // call tree from firing, in case they are reentrantly executed by finally-code 
  // in our call tree. See also the tertiary waitfor/and/or sjs-testsuite testcases
  // 153-156.
  quench: function() {
    this.child_frame.quench();
  },

  abort: function() {
    // XXX do we have to worry about reentrant abortion in the generic
    // case, or is everything covered by our handling in Seq?
    return this.child_frame.abort();
  },

  returnToParent: function(val) {
    if(is_cfx(val) && val.type == 't') {
      if(this.lineno && this.env) {
        var reason = 'EF_Proto.returnToParent';
        annotate_exception_stack(val, this.env.file, this.lineno(), reason);
      }
    }
    if (this.swallow_r) {
      if (is_cfx(val)) {
        if (val.type == "r") {
          if (!val.ef || val.ef == this) 
            val = val.val;
        }
      }
      else if (is_ef(val))
        val.swallow_r = this.swallow_r; // pass down flag to child
      else if (this.swallow_r != 2)
        val = UNDEF; // only 'return' returns a value to parent
    }
  
    // Mark this frame as unreturnable. This is used by
    // blocklambdas to determine if the lexical function container is
    // still alive.
    this.unreturnable = true;

    // a little cleanup which might aid GC:
#ifndef STACKTRACES
    this.env = UNDEF;
#endif

    if (this.async) {
      if (this.parent) {
        this.parent.cont(this.parent_idx, val);
        // remove parent to aid gc; we can only do this if val != this
        // (par and alt call through returnToParent via abortInner, which in the 
        // async case returns their own EF)
        // XXX empirically this doesn't seem to help much 
        // if (val !== this) this.parent = UNDEF;
      }
      else // noone waiting for result; make sure exceptions get reported
        if (is_cfx(val)) {
          // Chrome's console exception reporting mechanism doesn't
          // respect user-supplied toString. To get linenumbers we
          // throw with an augmented message here:
          val.mapToJS(true, this.env.file, this.lineno());
        }
    }
    else // sync context
      return val;
  }
};
//EF_Proto.__proto__ = null;

//----------------------------------------------------------------------
// Instruction nodes

// Token which identifies an object as an instruction node
// dispatcher (obj.__oni_dis == token_dis)
var token_dis = {};

// execute an instruction node without mapping exceptions:
function execIN(node, env) {
  if (!node || node.__oni_dis != token_dis) {
    return node; // a literal value
  }
  
  var result = node.exec(node.ndata, env);
  return result;
}
exports.ex = execIN;

// function bodies: create a seq and exec it. map exceptions.
// short for __oni_rt.exec(__oni_rt.Seq(...), aobj, thisobj, file)
// aobj: effective `arguments`
// tobj: effective `this`
exports.exseq = function(aobj,tobj,file, args) {
  var rv = I_seq(args, new Env(aobj,tobj,file));
//  var rv = (new EF_Seq(args, new Env(aobj,tobj,file))).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS();
  return rv;
};

// block lambda bodies: create a seq and exec it. don't map exceptions.
// short for __oni_rt.exec(__oni_rt.Seq(...), env)
exports.exbl = function(env, args) {
  var rv = I_seq(args, env);
//  var rv = (new EF_Seq(args, env)).cont(1);
  if (is_cfx(rv))
    return rv.mapToJS();
  return rv;
};


//   exec: instruction executor function
//   returns IN constructor function which returns a instruction object
function makeINCtor(exec, lineno) {
  return function(/* ndata */) {
    return {
      exec: exec,
      lineno: lineno || EF_Proto.lineno,
      ndata: arguments,
      __oni_dis: token_dis
    };
  }
}

//----------------------------------------------------------------------
// Execution environment
/*

  {
    aobj: 'arguments' object,
    tobj: 'this' object,
    file: filename,
    ref: function execution frame (only for non-tail-called functions that
         might be targetted by blocklambdas; see EF_Seq)
    bef: 'break' execution frame
    cef: 'continue' execution frame
  }

*/

function Env(aobj, tobj, file, ref, bef, cef) { 
  this.aobj = aobj; // 'arguments' object
  this.tobj = tobj; // 'this' object
  this.file = file; // filename
  this.ref = ref;
  this.bef = bef;
  this.cef = cef;
}

function copyEnv(e) {
  return new Env(e.aobj, e.tobj, e.file, e.ref, e.bef, e.cef);  
}

//----------------------------------------------------------------------
// Nb : instruction node for non-blocking, argument-less javascript code 
// Calls the given function with 'this' set to current environment.

// structure of ndata array:
#define NDATA_NBLOCK_JSFUNC() ndata[0]
#define NDATA_NBLOCK_LINENO() ndata[1]
function I_nblock(ndata, env) {
  try {
    return (NDATA_NBLOCK_JSFUNC()).call(env);
  }
  catch (e) {
    if (!is_cfx(e)) {
      e = new CFException("t", e, NDATA_NBLOCK_LINENO(), env.file);
    }
    annotate_exception_stack(e, env.file, NDATA_NBLOCK_LINENO(), 'I_nblock catch');
    return e;
  }
}
exports.Nb = makeINCtor(I_nblock, function() { return this.NDATA_NBLOCK_LINENO(); });

var annotate_exception_stack = function(e, file, lineno, reason) {
  if(e.type != 't') {
    // LOG("skipping non-throw type " + e.type);
    return;
  }
  if (lineno == null) {
    LOG("skipping null lineno from: " + reason);
    return;
  }
  LOG("annotating exception " + e.val);
  if(!file) { return; }
  if(e.val instanceof Error || e.val instanceof Object) { // TODO: why are JS-thrown errors an Object instead of Error
    if(!e.val.__oni_msg) {
      e.val.__oni_msg = e.val.toString();
    }
    e.val.__oni_stack.push([file, lineno, reason]);

    // todo: this is surely a waste of effort in 90+% of cases, since the stack is not shown.
    e.val.stack = "";
    var last_line = null;
    for(var i=0; i<e.val.__oni_stack.length; i++) {
      var this_line = e.val.__oni_stack[i].slice(0,2).join(":");
      //TODO: this check is so hacky! And doesn't work in some cases.
      // Need to figure out exactly when a new line ought to be added
      if(this_line != last_line) {
        if(e.val.stack) e.val.stack += "\n";
        e.val.stack += this_line;
      }
      last_line = this_line;
    }
    LOG("oni_stack for " + e + " is now = " + e.val.__oni_stack.join("\n---"));
  } else {
    LOG("can't annotate error: " + e.val + ", as it is a " + typeof(e.val));
  }
};

//----------------------------------------------------------------------
// Bl : instruction node for block lambdas

// structure of ndata array:
#define NDATA_BLOCKLAMBDA_JSFUNC() ndata[0]
function I_blocklambda(ndata, env) {
  ASSERT(env.ref)
  return (function() { return (NDATA_BLOCKLAMBDA_JSFUNC()).apply(env, arguments); });
}
exports.Bl = makeINCtor(I_blocklambda);

//----------------------------------------------------------------------
// Seq : instruction node for sequential execution of child nodes

// ndata[0] contains flags.
#define NDATA_SEQ_FLAGS() ndata[0]
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE SEQ_FLAG_'s in kernel-sjs.js.in
#define NDATA_SEQ_FLAG_NONE 0
#define NDATA_SEQ_FLAG_FUNCTION 1
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_OR 2
#define NDATA_SEQ_FLAG_SHORTCIRCUIT_AND 4
#define NDATA_SEQ_FLAG_NOTAILCALL 8
#define NDATA_SEQ_FLAG_UNRETURNABLE 16
#define NDATA_SEQ_FLAG_IMPLICIT_RETURN 32 

// ndata[1..end] contains sequence of instruction nodes

/*
  continuation index:
  1      : start
  2..end : returning from ndata[n-1] (last one tail-called)  
 */

function EF_Seq(ndata, env) {
  this.ndata = ndata;
  this.env = env;

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL) 
    env.ref = this; // note down function execution frame in environment

  this.tailcall = !(NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL);
  //WHENDEBUG(if (!this.tailcall) console.log("no tailcall!!");)
  // do we 'catch' returns? (also implies that we're catching stray break/continue)
  // swallow_r == true : 'catch' returns
  // swallow_r == 2    : allow implicit returns (i.e. last expression returns result)
  this.swallow_r = NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION;
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_IMPLICIT_RETURN)
    this.swallow_r = 2;

  // short-circuited?:
  this.sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                 NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 

  // is this a top-level seq (one that can't be return'ed to?)
  this.unreturnable = NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_UNRETURNABLE;
  this.last_idx = 0;
}
setEFProto(EF_Seq.prototype={});
#ifdef EF_TYPES
EF_Seq.prototype.type = "Seq";
#endif
EF_Seq.prototype.lineno = function() {
  if(this.last_idx >= this.ndata.length) {
    LOG("SEQ_IDX_FUDGE" + this.last_idx + " -> " + (this.ndata.length - 1));
    this.last_idx = this.ndata.length - 1; // XXX: is this correct?
    // return 'TODO, idx>length of ' + this.id;
  }
  if(this.last_idx == 0)
  {
    return "[SEQ_FLags!?] [id=" + this.id + "]";
  }
  if(this.last_idx === undefined || this.last_idx < 1) {
    return 'TODO, idx=' + String(this.last_idx);
  }
  if(this.last_idx > this.ndata.length) {
    return 'TODO, overflow: ' + String(this.last_idx);
  }
  if(!this.ndata[this.last_idx].lineno) {
    return '?? (' + this.ndata[this.last_idx].type + ')';
  }
  return this.ndata[this.last_idx].lineno();
};
EF_Seq.prototype.cont = function(idx, val) {
  var self = this;
  var getLine = function(idx) {
    var lineno = drill(self, 'ndata', idx, 'lineno');
    if (lineno && lineno.call) {
      var val = lineno.call(self.ndata[idx]);
      if (val) return val;
      return String(lineno);
    }
    return "??: ";
  };
  var getType = function(val) {
    var sub = val && val.type;
    return "Seq/" + (sub || "??");
  };
  LOG("EF_Seq.prototype.cont(" + idx + " of " + this.ndata.length + ", val[ef=" + is_ef(val) + ",cfx=" + is_cfx(val) + "]) @ " + this.env.file + ":" + getLine(idx));

  if (is_ef(val)) {
    // child frame being replaced:
    this.last_idx = idx; // TODO: clean up needed for this
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val)) {
    // pass through an exception:
    this.last_idx = idx; // TODO: clean up needed for this
    return this.returnToParent(val);
  }
  else {
    while (idx<this.ndata.length) {
      this.last_idx = idx; // TODO: clean up needed for this
      if (this.sc && idx > 1) {
        // short-circuit logic (for '||' & '&&')
        if (this.sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
          if (val) break; // returns val
        }
        else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
          if (!val) break; // returns val
        }
      }
      this.child_frame = null; // ensures correct reentrant aborting
      val = execIN(this.ndata[idx], this.env);
      if (this.aborted) {
        // a reentrant abortion
        if (is_ef(val)) {
          val.quench(); // not sure this is needed here XXX
          val = val.abort();
        }
        break;
      }
      var actual_idx = idx; // note the ++idx below.
      idx += 1;
#if !TAIL_CALLS
      this.tailcall = false;
#endif
      if ((idx == this.ndata.length && this.tailcall) || is_cfx(val)) {
        // tail call optimization: 
        break;
      }
      if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
    }
    return this.returnToParent(val);
  }
};

EF_Seq.prototype.quench = function() {
  if (this.child_frame) this.child_frame.quench();
};  

EF_Seq.prototype.abort = function() {
  //  LOG("Seq: aborting")
  if (!this.child_frame) {
    // reentrant abortion
    this.aborted = true;
    return this;
  }
  else
    return this.child_frame.abort();
};

#ifdef HOTPATH
function I_seq(ndata, env) {
  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_NOTAILCALL)
    return (new EF_Seq(ndata, env)).cont(1);

  var sc = NDATA_SEQ_FLAGS() & (NDATA_SEQ_FLAG_SHORTCIRCUIT_OR |
                                NDATA_SEQ_FLAG_SHORTCIRCUIT_AND); 
  var idx = 1;
  var val;
  var l = ndata.length;
  while (idx<l) {
    val = execIN(ndata[idx++], env);
    if (is_cfx(val)) break;
    if (is_ef(val)) {
      // need to create an execution frame for ourselves... 
      var ef = new EF_Seq(ndata, env);
      ef.setChildFrame(val, idx);
      return ef;
    }
    if (sc) {
      if (sc == NDATA_SEQ_FLAG_SHORTCIRCUIT_OR) {
        if (val) break; // returns val
      }
      else { // == NDATA_SEQ_FLAG_SHORTCIRCUIT_AND
        if (!val) break; // returns val
      }
    }
  }

  if (NDATA_SEQ_FLAGS() & NDATA_SEQ_FLAG_FUNCTION) {
    if (is_cfx(val)) {
      if (val.type == "r") {
        if (!val.ef)
          val = val.val;
      }
    }
    else
      val = UNDEF;
  }
  return val;
}
#else // !HOTPATH
function I_seq(ndata, env) {
  return (new EF_Seq(ndata, env)).cont(1);
}
#endif // HOTPATH
exports.Seq = makeINCtor(I_seq, EF_Seq.prototype.lineno);
exports.seq = I_seq;

//----------------------------------------------------------------------
// Sc : simple strict function call
//
// executes env.SC_L(arg1, arg2, ...) where arg1..n are strictly
// evaluated instruction nodes


// structure of ndata array:
#define NDATA_SC_LINE() ndata[0]
#define NDATA_SC_L() ndata[1]
#define NDATA_SC_ARGS_OFFSET 2
// ndata[NDATA_SC_ARGS_OFFSET..end] : sc args

/*
  continuation index:
   0 : start
   1 : returning from args evaluation
*/

function EF_Sc(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_SC_ARGS_OFFSET;
  this.pars = [];
}
setEFProto(EF_Sc.prototype={});

EF_Sc.prototype.lineno = function() { return this.NDATA_SC_LINE(); };
EF_Sc.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val)) {
    return this.returnToParent(val);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      this.pars.push(val);
    }
    var rv;
    while (this.i<this.ndata.length) {
      rv = execIN(this.ndata[this.i], this.env);
      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1);
        return this;
      }
      this.pars.push(rv);
    }
    
    // alright, we've got the pars, let's do the call:
    try {
        rv = this.NDATA_SC_L().apply(this.env, this.pars);
    }
    catch (e) {
      rv = new CFException("t", e,
                           this.NDATA_SC_LINE(),
                           this.env.file);
    }
    return this.returnToParent(rv);
  }
};

function I_sc(ndata, env) {
  return (new EF_Sc(ndata, env)).cont(0);
}

exports.Sc = makeINCtor(I_sc, EF_Sc.prototype.lineno);

//----------------------------------------------------------------------
// Fcall : instruction node for calling a function 

// IE-safe helper to determine if something is a function
function testIsFunction(f) {
  if (typeof f == "function") return true;
  // ... else, the IE/Safari workarounds (some things like
  // document.getElementById are not functions)
  // try 1:
//  return ((""+f).indexOf("[native code]") != -1) ||
//    ((""+f).indexOf("Constructor]") != -1);
  // try 2: (doesn't catch "[object ...]")
//  return ((""+f).indexOf("[") != -1 ||
//          (""+f).indexOf("/") == 0 /* a regexp (needed for FF) */);
  // try 3:
  return !!/(?:\[[^o])|(?:^\/)/.exec(""+f);
}  

// structure of ndata array:
// mode: 0: normal call, 1: reference call, 2: 'new' call
#define NDATA_FCALL_MODE() ndata[0]
#define NDATA_FCALL_LINE() ndata[1]
#define NDATA_L_INDEX 2
#define NDATA_FCALL_L() ndata[2]
#define NDATA_FCALL_ARGS_OFFSET 3
// ndata[NDATA_FCALL_ARGS_OFFSET..end] : fcall args

/*
  continuation index:
   0 : start
   1 : returning from l/pars evaluation
   2 : returning from 'new' call (need to return 'this.o') 
*/

function EF_Fcall(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.i = NDATA_L_INDEX;
  this.pars = [];
}
setEFProto(EF_Fcall.prototype={});
#ifdef EF_TYPES
EF_Fcall.prototype.type = "Fcall";
#endif

EF_Fcall.prototype.lineno = function() { return this.NDATA_FCALL_LINE(); };
EF_Fcall.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else if (is_cfx(val)) {
    return this.returnToParent(val);
  }
  else if (idx == 2) {
    // returning from a 'new' call
    return this.returnToParent(this.o);
  }
  else {
    if (idx == 1) {
      // handle a result that has been passed in
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = val;
      else
        this.pars.push(val);
    }
    var rv;
    while (this.i<this.ndata.length) {
      rv = execIN(this.ndata[this.i], this.env);
      ++this.i;
      if (is_cfx(rv)) return this.returnToParent(rv);
      if (is_ef(rv)) {
        this.setChildFrame(rv, 1);
        return this;
      }
      if (this.i==NDATA_FCALL_ARGS_OFFSET)
        this.l = rv;
      else
        this.pars.push(rv);
    }
    
    // alright, we've got the left side + pars, let's do the call:
    try {
      switch (this.NDATA_FCALL_MODE()) {
      case 0:
      // 'normal' call
      // this optimization gives at least 10% performance boost vs 'eval'
      if (typeof this.l == "function" && this.l.apply /* required for regexes on chrome (and others?) */) {
        rv = this.l.apply(null, this.pars);
      } else if (!testIsFunction(this.l)) {
        rv = new CFException("t",
                             new Error("'"+this.l+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        var command = "this.l(";
        for (var i=0; i<this.pars.length; ++i) {
          if (i) command +=",";
          command += "this.pars["+i+"]";
        }
        command += ")";
        rv = eval(command);
      }
      break;
      case 1:
      // 'reference' call
      if (typeof this.l[0] === 'undefined') {
        rv = new CFException("t",
                             new Error("'"+this.l[1]+"' on '"+this.l[0]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else if (typeof this.l[0][this.l[1]] == "function") {
        // 'normal' function
        // XXX not sure this is actually faster or better than 'eval' below
        rv = this.l[0][this.l[1]].apply(this.l[0], this.pars);
      }
      else if (
#ifdef CLIENTSIDE
               /* The reason we predicate this test on !ie is that on
                  IE certain object methods throw an exception when
                  accessed as a value rather than a function call.
                  E.g. for a some xml 'X' returned by XMLHttpRequest
                  we can call X.getElementsByTagName("foo") but
                  accessing X.getElementsByTagName throws an
                  exception "Wrong number of arguments or invalid
                  property assignment"             */
               (UA != "msie") &&
#endif
               !testIsFunction(this.l[0][this.l[1]])) {
        // XXX examine if this test is useful anyway. does it give
        // us better error messages?
        rv = new CFException("t",
                             new Error("'"+this.l[0][this.l[1]]+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // a 'builtin' (on IE, maybe others)
        // can't call apply on it
        var command = "this.l[0][this.l[1]](";
        for (var i=0; i<this.pars.length; ++i) {
          if (i) command +=",";
          command += "this.pars["+i+"]";
        }
        command += ")";
        rv = eval(command);
      }
      break;
      case 2:
      // 'new' call
      
      // XXX this sucks big-time. we need to distinguish between
      // builtin objects and user functions :-(
      var ctor = this.l;
#ifdef NODEJS
      if (ctor && /\{ \[native code\] \}$/.exec(ctor.toString())) {
#else
      if (ctor && (ctor == Array || ctor == Boolean || ctor == Date || ctor == Error || ctor == EvalError || ctor == Function || ctor == Math || ctor == Number || ctor == Object || ctor == RangeError || ctor == ReferenceError || ctor == RegExp || ctor == String || ctor == SyntaxError || ctor == TypeError || ctor == URIError ||
#ifdef CLIENTSIDE
               ctor == window.XMLHttpRequest ||
               ctor == window.ActiveXObject  ||
               ctor == window.XDomainRequest ||
#endif
                   !ctor.apply /* this last one catches things like XMLHttpRequest on platforms other than opera */)) {
#endif // !NODEJS
        // ctor is one of the 'builtin' functions. we need to
        // construct it in a single stage:
        var pars = this.pars;
        var command = "new ctor(";
        for (var i=0; i<pars.length; ++i) {
          if (i) command +=",";
          command += "pars["+i+"]";
        }
        command += ")";

#ifdef NODEJS
        // TODO: get native stacks from non-node env
        var sandbox = {
          'pars': pars,
          'ctor': ctor
        };
        var vm = __oni_rt.nodejs_require("vm");
        var sandbox = vm.createContext();
        sandbox.pars = pars;
        sandbox.ctor = ctor;
        rv = vm.runInNewContext(command, sandbox, this.env.file);
#else
        rv = eval(command);
#endif
      }
      else if (!testIsFunction(ctor)) {
        rv = new CFException("t",
                             new Error("'"+ctor+"' is not a function"),
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
      }
      else {
        // ctor is a 'user' function, which could suspend under our feet.
        // we have to construct in two stages:
#ifdef NODEJS
        this.o = Object.create(ctor.prototype);
#else
        var f = new Function();
        f.prototype = ctor.prototype;
        this.o = new f();
#endif
        rv = ctor.apply(this.o, this.pars);
        if (is_ef(rv)) {
          // we need to stay in the picture
          this.setChildFrame(rv, 2);
          return this;
        }
        else {
        // special casing for return value handling (return 'o'
        // instead of rv if rv is not typeof object):
          if (!rv || "object function".indexOf(typeof rv) == -1) 
            rv = this.o;
        }
      }
      break;
      default:
      rv = new CFException("i", "Invalid Fcall mode");
      }
    }
    catch (e) {
      // XXX not sure if we should amend this
      // exception. it might have been thrown by JS code, and I'm
      // pretty sure if it was thrown by SJS code it will already
      // have been amended.
      // The *pragmatic* thing seems to be to annotate.
//      rv = new CFException("t", e, "passthrough");
      LOG("suspicious events follow with " + e);
      if (is_cfx(e))
        rv = e;
      else
        rv = new CFException("t", e,
                             this.NDATA_FCALL_LINE(),
                             this.env.file);
    }
    return this.returnToParent(rv);
  }
};

function I_fcall(ndata, env) {
  return (new EF_Fcall(ndata, env)).cont(0);
}

exports.Fcall = makeINCtor(I_fcall, EF_Fcall.prototype.lineno);

//----------------------------------------------------------------------
// If : instruction node for executing 'if'

// structure of ndata array:
#define NDATA_IF_TEST() ndata[0]
#define NDATA_IF_CONSEQUENT() ndata[1]
#define NDATA_IF_ALTERNATIVE() ndata[2]

/*
  continuation index:
   0 : start
   1 : returning from test evaluation
*/

function EF_If(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_If.prototype={});
#ifdef EF_TYPES
EF_If.prototype.type = "If";
#endif

EF_If.prototype.cont = function(idx, val) {
  switch (idx) {
  case 0:
  //  LOG("IF: exec test")
  val = execIN(this.NDATA_IF_TEST(), this.env);
  //  LOG("IF: test execed:"+val)
  case 1:
  if (is_cfx(val)) break;
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  // tail calls:
  if (val)
    val = execIN(this.NDATA_IF_CONSEQUENT(), this.env);
  else
    val = execIN(this.NDATA_IF_ALTERNATIVE(), this.env);
  break;
  default:
  val = new CFException("i", "invalid state in EF_If");
  }
  return this.returnToParent(val);
};

function I_if(ndata, env) {
  return (new EF_If(ndata, env)).cont(0);
}

exports.If = makeINCtor(I_if);

//----------------------------------------------------------------------
// Switch: instruction node for executing 'switch() { case/default }'

// exported objected designating a 'default' clause:
var Default = {};
exports.Default = Default;

// structure of ndata array:
#define NDATA_SWITCH_EXP() ndata[0]
#define NDATA_SWITCH_CLAUSES() ndata[1]

/*
  continuation index:

phase 0: (evaling switch exp)

   0    : start
   1    : returning from switch expression evaluation

phase 1: (testing clause exp)
   -1   : entering from switch exp evaluation
   0..n : returning from given clause exp 


phase 2: (executing clause code)

   0...n : next clause to run
*/

function EF_Switch(ndata, env) {
  this.ndata = ndata;
  this.env = copyEnv(env);
  this.env.bef = this;
  this.phase = 0;
}
setEFProto(EF_Switch.prototype={});
#ifdef EF_TYPES
EF_Switch.prototype.type = "Switch";
#endif

EF_Switch.prototype.cont = function(idx, val) {
  switch (this.phase) {
  case 0: // evaluate switch expression
  if (idx == 0) {
    val = execIN(this.NDATA_SWITCH_EXP(), this.env);
  }
  if (is_cfx(val)) return this.returnToParent(val);
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    return this;
  }
  this.phase = 1;
  this.testval = val;
  idx = -1;
  case 1: // test clauses until we find a matching one
  while (true) {
    if (idx > -1) { // returning from evaluation of clause test idx
      if (is_cfx(val)) return this.returnToParent(val);
      if (is_ef(val)) {
        this.setChildFrame(val, idx);
        return this;
      }
      else if (val == Default || val == this.testval)
        break; // go into phase 2!
    }
    if (++idx >= this.NDATA_SWITCH_CLAUSES().length)
      return this.returnToParent(null); // all done; no matching clause found
    // test next clause:
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][0], this.env);
  }
  this.phase = 2;
  val = 0;
  case 2: // run clauses
  while (true) {
    if (is_ef(val)) {
      this.setChildFrame(val, idx);
      return this;
    }
    if (is_cfx(val)) {
      if (val.type == "b" && (!val.ef || val.ef == this)) {
        val = val.val;
      }
      return this.returnToParent(val);
    }
    if (idx >= this.NDATA_SWITCH_CLAUSES().length) {
      return this.returnToParent(val);
    }
    val = execIN(this.NDATA_SWITCH_CLAUSES()[idx][1], this.env);
    ++idx
  }
  default:
  throw "Invalid phase in Switch SJS node";
  }
};

function I_switch(ndata, env) {
  return (new EF_Switch(ndata, env)).cont(0);
}

exports.Switch = makeINCtor(I_switch);

//----------------------------------------------------------------------
// Try : instruction node for try/catch/finally

// structure of ndata array:
// ndata[0] contains flags.
// THESE FLAGS NEED TO BE KEPT IN SYNC WITH THE TRY_FLAG_'s in kernel-sjs.js.in
#define NDATA_TRY_FLAG_NONE 0
#define NDATA_TRY_FLAG_CATCHALL 1

#define NDATA_TRY_FLAGS() ndata[0]
#define NDATA_TRY_TRY_BLOCK() ndata[1]
#define NDATA_TRY_CATCH_FUNC() ndata[2]
#define NDATA_TRY_FINALLY_BLOCK() ndata[3]
#define NDATA_TRY_RETRACT_BLOCK() ndata[4]

/*
  continuation index not used, we use this.state instead (since we
  need to know the state when we get an abort):

  0 : start
  1 : returning from try block
  2 : returning from catch
  3 : returning from retract
  4 : returning from finally

*/

function EF_Try(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.state = 0;
}
setEFProto(EF_Try.prototype={});
#ifdef EF_TYPES
EF_Try.prototype.type = "Try";
#endif

EF_Try.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, this.state);
  }
  else {
    switch (this.state) {
    case 0:
    this.state = 1;
    val = execIN(this.NDATA_TRY_TRY_BLOCK(), this.env);
    if (is_ef(val)) {
      this.setChildFrame(val);
      return this;
    }
    case 1:
    // returning from try block
    this.state = 2;
    if (!this.aborted &&
        this.NDATA_TRY_CATCH_FUNC() &&
        ((is_cfx(val) && val.type == "t") ||
         this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_CATCHALL)) {
      try {
        var v;
        if (this.NDATA_TRY_FLAGS() & NDATA_TRY_FLAG_CATCHALL) {
          // we'll pass an array [rv|exception, isexception] to the
          // catch function
          v = is_cfx(val) ? [val.val, true] : [val, false];
        }
        else // 'normal' exception catching
          v = val.val;
        val = this.NDATA_TRY_CATCH_FUNC()(this.env, v);
      } catch (e) {
        // XXX do we need this????
        // XXX does this need to be wrapped?
        val = new CFException("t", e);
      }
      var catch_fn = this.NDATA_TRY_CATCH_FUNC();
      if (is_ef(val)) {
        this.setChildFrame(val);
        return this;
      }
    }
    case 2:
    // returning from try/catch
    this.state = 3;
    // save value from catch/try (the value from the retract block
    // never matters):
    this.rv = val;
    if (this.aborted && this.NDATA_TRY_RETRACT_BLOCK()) {
      val = execIN(this.NDATA_TRY_RETRACT_BLOCK(), this.env);
      if (is_ef(val)) {
        this.setChildFrame(val);
        return this;
      }
    }
    case 3:
    // returning from try/catch/retract
    this.state = 4;
    if (this.NDATA_TRY_FINALLY_BLOCK()) {
      val = execIN(this.NDATA_TRY_FINALLY_BLOCK(), this.env);
      // we can't tail-call this, because we might have to return
      // the stored rv (if it is an exception)
      if (is_ef(val)) {
        this.setChildFrame(val);
        return this;
      }
    }
    case 4:
    // returning from finally        
    // override res with stored exception (from try or catch) if
    // val isn't an exception
    if (is_cfx(this.rv) && !is_cfx(val)) {
      val = this.rv;
    }
    break;
    default:
    val = new CFException("i", "invalid state in CF_Try");
    }
    return this.returnToParent(val);
  }
};

EF_Try.prototype.quench = function() {
  if (this.state != 4) // don't quench inside finally block
    this.child_frame.quench();
};

EF_Try.prototype.abort = function() {
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  this.parent = UNDEF;
  ASSERT(this.aborted != true) // sanity check; aborted before
  this.aborted = true;
  ASSERT(this.state != 3) // sanity check; aborted before
  if (this.state != 4) { // don't abort finally block
    var val = this.child_frame.abort();
    if (is_ef(val)) {
      // we need to wait for the try or catch block, and then let
      // cont() proceed with retract/finally:
      this.setChildFrame(val);
    }
    else {
      // attempt to execute retract/finally blocks synchronously:
      if (this.cont(0, UNDEF) != this)
        return;
      // ... else fall through. we need to block
    }
  }
  return this;
};

function I_try(ndata, env) {
  return (new EF_Try(ndata, env)).cont(0);
}

exports.Try = makeINCtor(I_try);

//----------------------------------------------------------------------
// Loop : instruction node for looping constructs

// structure of ndata array:
#define NDATA_LOOP_INIT_STATE() ndata[0]
#define NDATA_LOOP_TEST() ndata[1]
#define NDATA_LOOP_INC() ndata[2]
#define NDATA_LOOP_BODY(i) ndata[i+1]

/*
  continuation index:
   0 : perform test next
   2 - ndata.length+2 : perform body NDATA_LOOP_BODY+i-2 next
   1 : perform inc next 
*/

function EF_Loop(ndata, env) {
  this.ndata = ndata;
  this.env = copyEnv(env);
  this.env.bef = this.env.cef = this;
}
setEFProto(EF_Loop.prototype={});
#ifdef EF_TYPES
EF_Loop.prototype.type = "Loop";
#endif

EF_Loop.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    while (true) {
      // test:
      if (idx == 0) {
        if (is_cfx(val)) {
          // maybe return value from body here
          return this.returnToParent(val);
        }
        // perform loop test
        val = execIN(this.NDATA_LOOP_TEST(), this.env);
        if (is_ef(val)) {
          this.setChildFrame(val, 2);
          return this;
        }
        idx = 2; // body next
      }
      // body:
      if (idx > 1) {
        if (idx == 2) {
          // examine return value from loop test:
          if (!val || is_cfx(val)) {
            // maybe return value from body here
            return this.returnToParent(val);
          }
        }
        while (1) {
          if (idx > 2) {
            if (is_cfx(val)) {
              if (!val.ef || val.ef == this) {
                if (val.type == "b") {
                  // break statement
                  val = UNDEF;
                }
                else if (val.type == "c") {
                  // continue statement
                  val = UNDEF;
                  // break out of the loop; pick up again at increment:
                  break;
                }
              }
              return this.returnToParent(val);
            }
            if (idx >= this.ndata.length)
              break; // pick up at increment
          }
            
          // perform body
          val = execIN(this.NDATA_LOOP_BODY(idx), this.env);
          ++idx;
          if (is_ef(val)) {
            this.setChildFrame(val, idx);
            return this;
          }
        }
        idx = 1;
      }
      // this point will be reached directly if idx = 1
      if (this.NDATA_LOOP_INC())  {
        // perform inc
        val = execIN(this.NDATA_LOOP_INC(), this.env);
        if (is_ef(val)) {
          this.setChildFrame(val, 0);
          return this;
        }
      }
      idx = 0;
    }
  }
};

function I_loop(ndata, env) {
  return (new EF_Loop(ndata, env)).cont(NDATA_LOOP_INIT_STATE(), true);
}

exports.Loop = makeINCtor(I_loop);

//----------------------------------------------------------------------
// ForIn : instruction node for 'for-in' loops

// structure of ndata array
#define NDATA_FORIN_OBJ()  ndata[0]
#define NDATA_FORIN_LOOPF() ndata[1]

/*
  continuation index:
   0   : start
   1   : returning from evalution of forin obj
   2   : returning from loopf
*/

function EF_ForIn(ndata, env) {
  this.ndata = ndata;
  this.env = copyEnv(env);
  this.env.bef = this.env.cef = this;
}
setEFProto(EF_ForIn.prototype={});
#ifdef EF_TYPES
EF_ForIn.prototype.type = "ForIn";
#endif

EF_ForIn.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == 0) {
      val = execIN(this.NDATA_FORIN_OBJ(), this.env);
      if (is_ef(val)) {
        this.setChildFrame(val, 1);
        return this;
      }
      idx = 1;
    }
    if (idx == 1) {
      // returning from evaluation of forin obj
      if (is_cfx(val))
        return this.returnToParent(val);
      for (var x in val) {
        if (typeof this.remainingX === 'undefined') {
          val = this.NDATA_FORIN_LOOPF()(this.env,x);
          if (is_cfx(val)) {
            if (!val.ef || val.ef == this) {
              if (val.type == "b") {
                // break statement
                val = UNDEF;
              }
              else if (val.type == "c") {
                // continue
                val = UNDEF;
                continue;
              }
            }
            return this.returnToParent(val);
          }
          if (is_ef(val))
            this.remainingX = [];
        }
        else
          this.remainingX.push(x);
      }
      if (is_ef(val)) {
        if (!this.remainingX) this.remainingX = [];
        this.setChildFrame(val, 2);
        return this;
      }
      // all done
      return this.returnToParent(val);
    }
    if (idx == 2) {
      while (1) {
        // returning from evaluation of loop
        if (is_cfx(val)) {
          if (!val.ef || val.ef == this) {
            if (val.type == "b") {
              // break
              val = UNDEF;
            }
            else if (val.type == "c") {
              // continue
              val = UNDEF;
              if (this.remainingX.length)
                continue;
            }            
          }
          return this.returnToParent(val);
        }
        if (is_ef(val)) {
          this.setChildFrame(val, 2);
          return this;
        }
        if (!this.remainingX.length) {
          return this.returnToParent(val);
        }
        val = this.NDATA_FORIN_LOOPF()(this.env, this.remainingX.shift());
        // go round the loop again
      }
    }
  }
};

function I_forin(ndata, env) {
  return (new EF_ForIn(ndata, env)).cont(0);
}

exports.ForIn = makeINCtor(I_forin);

//----------------------------------------------------------------------
// Cfe : control flow exception (break, continue)

// structure of ndata array:
#define NDATA_CFE_TYPE() ndata[0]
#define NDATA_CFE_LBL() ndata[1]

function I_cfe(ndata, env) {
  var e = new CFException(NDATA_CFE_TYPE(), NDATA_CFE_LBL());
  e.ef = env[NDATA_CFE_TYPE() + 'ef'];
  if (!e.ef || e.ef.unreturnable) // the break/continue is mal-nested,
                                  // or the return frame is inactive!
    e = new CFException("t", new TypeError(e.toString()), 0, env.file);
  return e;
}

exports.Cfe = makeINCtor(I_cfe);

//----------------------------------------------------------------------
// Par : stratified par construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/

function EF_Par(ndata, env) {
  this.ndata = ndata;
  this.env = env;
  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Par.prototype={});
#ifdef EF_TYPES
EF_Par.prototype.type = "Par";
#endif

EF_Par.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        val = execIN(this.ndata[i], this.env);
        if (this.aborted) {
          // this check is to catch the case of reentrant abortion through
          // suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          return this.pendingCFE;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else if (is_cfx(val)) {
          // an exception aborts all other pending branches:
          this.pendingCFE = val;
          this.quench();
          return this.abortInner();
        }
      }
    }
    else {
      // returning from a suspension
      --this.pending;
      this.children[idx] = UNDEF;
      if (is_cfx(val) && !this.aborted) {
        // an exception aborts all other pending branches:
        this.pendingCFE = val;
        this.quench();
        return this.returnToParent(this.abortInner());
      }
    }
    if (this.pending < 2) {
      if (!this.pendingCFE) {
        // 'normal' return path:
        
        if (this.pending == 0)
          return this.returnToParent(val);
        // make a tail-call if there is only one last pending child:
        for (var i=0; i<this.children.length; ++i)
          if (this.children[i])
            return this.returnToParent(this.children[i]);
        return this.returnToParent(new CFException("i", "invalid state in Par"));
      }
      else {
        // There is a pending control flow exception which we need to return.
        // Therefore we can't do a tail call.
        if (this.pending == 0)
          return this.returnToParent(this.pendingCFE);
      }
    }
    this.async = true;
    return this;
  }
};

EF_Par.prototype.quench = function() {
  if (this.aborted) return; // already quenched/aborted internally
  for (var i=0; i<this.children.length; ++i) {
    if (this.children[i])
      this.children[i].quench();
  }
};

EF_Par.prototype.abort = function() {
  // prevent continuation from ending up at parent, we want to feed
  // it to the abortee directly:
  this.parent = UNDEF;
  if (this.aborted) {
    // we already aborted internally.
    // can delete pendingCFE; our caller is not interested in it
    this.pendingCFE = UNDEF;
    return this;
  }
  return this.abortInner();
};

EF_Par.prototype.abortInner = function() {
  // this function is both called for outside aborts (through
  // 'this.abort') as well as "internal" aborts (which occur when a
  // branch excepts)
  this.aborted = true;
  for (var i=0; i<this.children.length; ++i)
    if (this.children[i]) {
      var val = this.children[i].abort();
      if (is_ef(val)) // need to wait on this one...
        this.setChildFrame(val, i);
      else {
        --this.pending;
        this.children[i] = UNDEF;
      }
    }
  if (!this.pending) // all done
    return this.pendingCFE; // if there is no pending cfe, this is just 'undefined', which is ok.
  // we need to wait:
  this.async = true;
  return this;
};

EF_Par.prototype.setChildFrame = function(ef, idx) {
  this.children[idx] = ef;
  ef.parent = this;
  ef.parent_idx = idx;
};

function I_par(ndata, env) {
  return (new EF_Par(ndata, env)).cont(-1);
}

exports.Par = makeINCtor(I_par);

//----------------------------------------------------------------------
// Alt : stratified alt construct

// ndata[0..end] contains sequence of instruction nodes

/*
  continuation index:
   -1: start
   0..end: index of instruction node we're returning from
*/

function EF_Alt(ndata, env) {
  this.ndata = ndata;
  this.env = env;

  this.pending = 0;
  this.children = new Array(this.ndata.length);
}
setEFProto(EF_Alt.prototype={});
#ifdef EF_TYPES
EF_Alt.prototype.type = "Alt";
#endif

EF_Alt.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    this.setChildFrame(val, idx);
  }
  else {
    if (idx == -1) {
      // kick off all children
      for (var i=0; i<this.ndata.length; ++i) {
        // create a new environment for 'collapse' support
        // XXX it sucks that we have to create a new environment for each branch here 
        var env = copyEnv(this.env);
        env.ref = this.env.ref;
        env.fold = this;
        env.branch = i;
        val = execIN(this.ndata[i], env);
                     
        if (this.aborted) {
          // the check for !aborted here is to catch the case of
          // reentrant abortion through suspend/resume
          if (is_ef(val)) {
            ++this.pending;
            this.setChildFrame(val, i);
            this.quench();
            return this.abortInner();
          }
          return this.pendingRV;
        }
        else if (is_ef(val)) {
          ++this.pending;
          this.setChildFrame(val, i);
        }
        else {
          // an exception or real value aborts all other pending branches:
          this.pendingRV = val;
          this.quench();
          return this.abortInner();
        }
      }
    }
    else {
      // returning from a suspension. 
      --this.pending;
      this.children[idx] = UNDEF;
      if (this.collapsing) {
        // we're returning from an async abort after collapsing
        // (uncommon case; see comment below)
        if (this.pending == 1) {
          // only our collapsing branch is left; continue with it
          cf = this.collapsing.cf;
          this.collapsing = UNDEF;
          cf.cont(1);
        }
        return;
      }
      else {
        // 'normal' case
        // abort all pending branches
        if (!this.aborted) {
          this.pendingRV = val;
          this.quench();
          return this.returnToParent(this.abortInner());
        }
        if (this.pending == 0)
          return this.returnToParent(this.pendingRV);
      }
    }
    this.async = true;
    return this;
  }
};

EF_Alt.prototype.quench = function(except) {
  if (this.aborted) return; // already quenched/aborted internally
  if (this.collapsing) {
    // we're being quenched after a collapse; just quench the collapsing branch
    this.children[this.collapsing.branch].quench();
  }
  else {
    // common case, quench all branches (possibly except 'except')
    for (var i=0; i<this.children.length; ++i) {
      if (i!== except && this.children[i])
        this.children[i].quench();
    }
  }
};

EF_Alt.prototype.abort = function() {
  this.parent = UNDEF;
  if (this.aborted) {
    this.pendingRV = UNDEF;
    return this;
  }
  return this.abortInner();
};

EF_Alt.prototype.abortInner = function() {
  // see Par::abortInner for more details
  this.aborted = true;
  if (this.collapsing) {
    // we're being aborted after a collapse; just need to abort the collapsing branch
    var branch = this.collapsing.branch;
    this.collapsing = UNDEF;
    var val = this.children[branch].abort();
    if (is_ef(val)) // need to wait
      this.setChildFrame(val, branch);
    else {
      --this.pending;
      this.children[branch] = UNDEF;
    }
  }
  else {
    // common case: abort all branches
    for (var i=0; i<this.children.length; ++i)
      if (this.children[i]) {
        var val = this.children[i].abort();
        if (is_ef(val)) // need to wait
          this.setChildFrame(val, i);
        else {
          --this.pending;
          this.children[i] = UNDEF;
        }
      }
  }
  if (!this.pending)
    return this.pendingRV;
  this.async = true;
  return this;
};

EF_Alt.prototype.setChildFrame = function(ef, idx) {
  this.children[idx] = ef;
  ef.parent = this;
  ef.parent_idx = idx;
};

EF_Alt.prototype.docollapse = function(branch, cf) {
  // abort all children apart from 'branch'
  this.quench(branch);
  for (var i=0; i<this.children.length; ++i) {
    if (i == branch) continue;
    if (this.children[i]) {
      var val = this.children[i].abort();
      if (is_ef(val)) // need to wait
        this.setChildFrame(val, i);
      else {
        --this.pending;
        this.children[i] = UNDEF;
      }
    }
  }

  if (this.pending <= 1) // =0 for sync case, =1 for async case 
    return true;
  // ... else we need to wait
  // this only happens if there is an asynchronous finally-clause 
  // in one of the aborted branches (i.e. not a very common case)
  this.collapsing = { branch:branch, cf:cf};
  return false;
};

function I_alt(ndata, env) {
  return (new EF_Alt(ndata, env)).cont(-1);
}

exports.Alt = makeINCtor(I_alt);

//----------------------------------------------------------------------
// Suspend: stratified suspend operation

#ifdef ASYNC_RESUME
var ResumeQueue = {
  messages: [],
  pickup_pending: false,
  post: function(resume_struct) {
    this.messages.push(resume_struct);
    if (!this.pickup_pending) {
      this.pickup_pending = true;
#ifdef CLIENTSIDE
      setTimeout(function() { ResumeQueue.pickup(); }, 0);
#else
      callAsync(function() { ResumeQueue.pickup(); });
#endif
    }
  },
  pickup: function() {
    this.pickup_pending = false;
    var ms = this.messages;
    this.messages = [];
    for (var i=0; i<ms.length; ++i) {
      var m = ms[i];
      m[0].cont(m[1],m[2]);
    }
  }
};
exports.Q = ResumeQueue;
#endif

// structure of ndata array:
#define NDATA_SUSPEND_SUSPENDFUNC() ndata[0]
#define NDATA_SUSPEND_RETURNFUNC() ndata[1]

/*
  continuation index:
  0: start
  1: returning from execution of suspend function
  2: returning from execution of resume function
  3: returning from abortion of suspend function

  state variables:
  returning: resume function has been called or suspend threw
  suspendCompleted: suspend block has executed completely
  retvals: return values as passed into resume function
*/

function EF_Suspend(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Suspend.prototype={});
#ifdef EF_TYPES
EF_Suspend.prototype.type = "Suspend";
#endif

EF_Suspend.prototype.cont = function(idx, val) {
  if (is_ef(val)) {
    ASSERT(idx == 1 || idx == 3) //(others shouldn't rebase)
    this.setChildFrame(val, idx);
  }
  else {
    switch (idx) {
    case 0:
    try {
      var ef = this;
#ifdef ASYNC_RESUME
      var resumefunc = function() { ResumeQueue.post([ef,2,arguments]); };
#else
  // XXX We could return something from resumefunc
  var resumefunc = function() {
    try {
      ef.cont(2, arguments)
    }
    catch(e) {
      var s = function() { throw e; };
#if defined (CLIENTSIDE)
      setTimeout(s, 0);
#elif defined (NODEJS)
      process.nextTick(s);
#else
      callAsync(s);
#endif
    }
  };
      
#endif
      //      LOG("executing suspend")
      val = this.NDATA_SUSPEND_SUSPENDFUNC()(this.env, resumefunc);
    }
    catch (e) {
      // XXX is this required??
      val = new CFException("t", e);
    }
    //    LOG('done executing suspend')
    // At this point we might have received a reentrant callback
    // from the resume function!!
    if (this.returning) {
      //      LOG('reentrant cb')
      if (is_ef(val)) {
        ASSERT(!this.child_frame)
        // processing up to here has been synchronous; we still need to abort
        this.setChildFrame(val, /* not relevant */null);
        this.quench();
        val = this.abort();
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          // get parent to wait for us:
          this.async = true;
          return this;
        }
        // ... else fall through
      }
      return this.cont(3, null);
    }
    
    if (is_ef(val)) {
      this.setChildFrame(val, 1);
      return this;
    }
    case 1:
    // returning from execution of suspend function
    if (is_cfx(val)) {
      this.returning = true;
      break;
    }
    this.suspendCompleted = true;
    // suspend:
    this.async = true;
    return this;
    case 2:
    // returning from execution of resume function.        
    // Note that this might happen reentrantly, while we're still
    // processing the suspend block!!!
    if (this.returning) {
      // this is a trailing resume which we can safely ignore
      return;
    }
    this.returning = true;
    if (is_cfx(val)) {
      // sanity check
      // this shouldn't happen
      val = new CFException("i", "Suspend: Resume function threw ("+val.toString()+")");
      break;
    }
    this.retvals = val;
    if (!this.suspendCompleted) {
      // abort the suspend block:
      if (!this.child_frame) {
        // The suspend block is still executing synchronously.
        // This is a reentrant invocation of 'resume'.
        // We'll pick up with processing again when the suspend block is done
        this.returning = true;
        return;
      }
      else {
        this.quench();
        val = this.abort();
        if (is_ef(val)) {
          // wait for the abort to finish
          this.setChildFrame(val, 3);
          return this;
        }
        // ... else fall through to case 3
        //        LOG('synchronous abortion')
          }
    }
    case 3:
    // set values with return function:
    try {
      this.NDATA_SUSPEND_RETURNFUNC().apply(this.env, this.retvals);
      val = UNDEF;
    }
    catch (e) {
      val = new CFException("i", "Suspend: Return function threw ("+e+")");
    }
    break;
    default:
    val = new CFException("i", "Invalid state in Suspend ("+idx+")");
    }
    return this.returnToParent(val);
  }
};

EF_Suspend.prototype.quench = function() {
  this.returning = true; // prevent resume() calls from having any effect
  if (!this.suspendCompleted)
    this.child_frame.quench();
};

EF_Suspend.prototype.abort = function() {
  //  LOG('SUSPEND abort (childf='+this.child_frame+')')
  this.returning = true;
  if (!this.suspendCompleted)
    return this.child_frame.abort();
};

function I_sus(ndata, env) {
  return (new EF_Suspend(ndata, env)).cont(0);
}

exports.Suspend = makeINCtor(I_sus);

//----------------------------------------------------------------------
// spawn

// structure of ndata array:
#define NDATA_SPAWN_LINE() ndata[0]
#define NDATA_SPAWN_EXP() ndata[1]

// continuation index:
// 0: start
// 1: returning from async execution
  
function EF_Spawn(ndata, env, notifyAsync, notifyVal) {
  this.ndata = ndata;
  this.env = env;
  this.notifyAsync = notifyAsync;
  this.notifyVal = notifyVal;
}
setEFProto(EF_Spawn.prototype={});
#ifdef EF_TYPES
EF_Spawn.prototype.type = "Spawn";
#endif

EF_Spawn.prototype.lineno = function() { return this.NDATA_SPAWN_LINE(); };
EF_Spawn.prototype.cont = function(idx, val) {
  if (idx == 0)
    val = execIN(this.NDATA_SPAWN_EXP(), this.env);
  
  if (is_ef(val)) {
    this.setChildFrame(val, 1);
    if (idx == 0)
      this.notifyAsync();
  }
  else {
    this.notifyVal(val);
  }
};

function EF_SpawnWaitFrame(waitarr) {
  this.waitarr = waitarr;
  waitarr.push(this);
}
setEFProto(EF_SpawnWaitFrame.prototype={});
#ifdef EF_TYPES
EF_SpawnWaitFrame.prototype.type = "Spawn";
#endif
EF_SpawnWaitFrame.prototype.quench = function() {};
EF_SpawnWaitFrame.prototype.abort = function() {
  var idx = this.waitarr.indexOf(this); // assert != -1
  this.waitarr.splice(idx, 1);
}
EF_SpawnWaitFrame.prototype.cont = function(val) {
  if (this.parent)
    this.parent.cont(this.parent_idx, val);
}

function I_spawn(ndata, env) {
  var val, async, have_val, picked_up=false;
  var waitarr = [];
  var stratum = {
    abort : function() {
      if (!async) return;
      ef.quench();
      ef.abort();
      async = false;
      val =  new CFException("t",
                             new Error("stratum aborted"),
                             NDATA_SPAWN_LINE(),
                             env.file);
      while (waitarr.length)
        waitarr.shift().cont(val);
    },
    waitforValue : function() {
      if (!async) { picked_up=true; return val; }
      return new EF_SpawnWaitFrame(waitarr);
    },
    waiting : function() {
      return waitarr.length;
    },
    toString: function() { return "[object Stratum]"; }
  };
      
  function notifyAsync() {
    async = true;
  }
  function notifyVal(_val) {
    val = _val;
    async = false;
    if (!waitarr.length) {
      // make sure exceptions that noone is waiting on get reported in
      // console. Don't report exceptions that aren't instanceof Error;
      // IE shows a popup for uncaught exceptions, and exceptions
      // without linenumbers etc are very confusing
      if (is_cfx(val) && val.val instanceof Error) {
        // Chrome's console exception reporting mechanism doesn't
        // respect user-supplied toString. To get linenumbers we throw
        // as an augmented message here:
        
        // It is essential that we throw the exception *asynchronously*
        // when async = false. Otherwise it will end up at our
        // caller. For simplicity we always throw asynchronously:
        setTimeout(function() { 
          // We only throw if the value hasn't been picked up in the
          // meanwhile. This is for cases where we have:
          //   var stratum = spawn synchronous_throw_here;
          //   stratum.waitforValue();
          // We want to prevent the exception feeding to the user twice in this case
          if (!picked_up)
            val.mapToJS(true, env.file, NDATA_SPAWN_LINE()); 
        }, 
                   0);
      }
    }
    else
      while (waitarr.length)
        waitarr.shift().cont(val);
    
  }
  var ef = new EF_Spawn(ndata, env, notifyAsync, notifyVal);
  ef.cont(0);
  return stratum;
}
  
exports.Spawn = makeINCtor(I_spawn, EF_Spawn.prototype.lineno);

//----------------------------------------------------------------------
// collapse

// structure of ndata array:
#define NDATA_COLLAPSE_LINE() ndata[0]

// continuation index:
// 0: start
// 1: returning from async execution
  
function EF_Collapse(ndata, env) {
  this.ndata = ndata;
  this.env = env;
}
setEFProto(EF_Collapse.prototype={});
#ifdef EF_TYPES
EF_Collapse.prototype.type = "Collapse";
#endif

// mark us as a collapse frame
EF_Collapse.prototype.__oni_collapse = true;

EF_Collapse.prototype.lineno = function() { return this.NDATA_COLLAPSE_LINE(); };
EF_Collapse.prototype.cont = function(idx, val) {
  if (idx == 0) {
    var fold = this.env.fold;
    if (!fold)
      return new CFException("t", new Error("Unexpected collapse statement"),
                             this.NDATA_COLLAPSE_LINE(), this.env.file);
    if (fold.docollapse(this.env.branch, this))
      return true;
    // else ... we're going async
    this.async = true;
    return this;
  }
  else if (idx == 1) // returning from collapsing
    this.returnToParent(true);
  else 
    this.returnToParent(new CFException("t", "Internal error in SJS runtime (collapse)",
                                        this.NDATA_COLLAPSE_LINE(), this.env.file));
};

// don't need to do anything for quenching/aborting. we'll never be prodded by upstream after an abort.
EF_Collapse.prototype.quench = function() {};
EF_Collapse.prototype.abort = function() {};

function I_collapse(ndata, env) {
  return (new EF_Collapse(ndata, env)).cont(0);
}
  
exports.Collapse = makeINCtor(I_collapse, EF_Collapse.prototype.lineno);
  
//----------------------------------------------------------------------
// builtin strict functions

function dummy() {}

exports.Hold = function(/*args*/) {
  if (!arguments.length)
    return { __oni_ef: true, quench: dummy, abort: dummy };
  var sus = { __oni_ef: true,
              abort: dummy,
#if defined (CLIENTSIDE) || defined (NODEJS)
              quench: function() { sus = null; clearTimeout(this.co); }
#else
              quench: function() { sus = null; this.co.cancel(); }
#endif
            };
  sus.co = setTimeout(function() { if (sus && sus.parent) sus.parent.cont(sus.parent_idx, UNDEF); },
                      arguments[0]);
  return sus;
};

exports.Throw = function(exp, line, file) { return new CFException("t", exp, line, file); };

exports.Arr = function(/*args*/) { return Array.prototype.slice.call(arguments, 0); };

exports.Obj = function(/*args*/) {
  // note comment in kernel-sjs.js.in::ph_obj_lit about the way props
  // are encoded into arguments object
  var obj = new Object();
  for (var i=0; i<arguments[0].length; ++i)
    obj[arguments[0][i]] = arguments[i+1];
  return obj;
};

exports.Return = function(exp) {
//  var e = new CFException("r", exp);
//  return e;
  return exports.CFER(this, exp);
};

exports.With = function(exp, bodyf) {
  return bodyf(this, exp);
};

exports.sum = function() {
  var rv = '';
  for (var i=0,l=arguments.length;i<l;++i)
    rv += arguments[i];
  return rv;
};

exports.infix = {
  '+':   function(a,b) { return a+b; },
  '-':   function(a,b) { return a-b; },
  '*':   function(a,b) { return a*b; },
  '/':   function(a,b) { return a/b; },
  '%':   function(a,b) { return a%b; },
  '<<':  function(a,b) { return a<<b; },
  '>>':  function(a,b) { return a>>b; },
  '>>>': function(a,b) { return a>>>b; },
  '<':   function(a,b) { return a<b; },
  '>':   function(a,b) { return a>b; },
  '<=':  function(a,b) { return a<=b; },
  '>=':  function(a,b) { return a>=b; },
  '==':  function(a,b) { return a==b; },
  '!=':  function(a,b) { return a!=b; },
  '===': function(a,b) { return a===b; },
  '!==': function(a,b) { return a!==b; },
  '&':   function(a,b) { return a&b; },
  '^':   function(a,b) { return a^b; },
  '|':   function(a,b) { return a|b; },
  ',':   function(a,b) { return a,b; },
  'instanceof':
         function(a,b) { return a instanceof b; },
  'in':  function(a,b) { return a in b; }
};

#if defined (CLIENTSIDE)
//----------------------------------------------------------------------
// UA sniffing
var UA = navigator.userAgent.toLowerCase();
if (UA.indexOf(" chrome/") >= 0)
  UA = "chrome";
 else if (UA.indexOf(" firefox/") >= 0)
   UA = "firefox";
 else if (UA.indexOf(" safari/") >= 0)
   UA = "safari";
 else if (UA.indexOf(" msie ") >= 0)
   UA = "msie";
 else
   UA = "unknown";
exports.hostenv = "xbrowser";
#elif defined (NODEJS)
var UA = "nodejs";
exports.hostenv = "nodejs";
#endif
exports.UA = UA;

#if defined (CLIENTSIDE)
exports.G = window;
#elif defined (NODEJS)
exports.G = global;
#endif
