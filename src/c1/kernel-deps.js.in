/*
 * C1 JS/SJS->require() analysis compiler kernel  
 *
 * Part of StratifiedJS
 * http://onilabs.com/apollo
 *
 * (c) 2013 Oni Labs, http://onilabs.com
 *
 * This file is licensed under the terms of the GPL v2, see
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

//----------------------------------------------------------------------
// helpers:

var Object_prototype = Object.getPrototypeOf({}); // not the same as Object.prototype in nodejs sandbox
var has = function(o,k) { return Object.prototype.hasOwnProperty.call(o,k); };
var str = function(obj) {
  if (obj == null) return '<null>';
  if (Array.isArray(obj)) {
    return "[" + obj.map(str).join(", ") + "]";
  }
  if (obj && (obj.toString === Object_prototype.toString)) {
    var pairs = [];
    for (var k in obj) {
      if (!has(obj,k)) continue;
      pairs.push(k + ": " + str(obj[k]));
    }
    return "{" + pairs.join(", ") + "}";
  }
  return String(obj);
};
var assert = function(cond, desc) { if (!cond) throw new Error(desc || "Assertion failed"); return cond };

var nonReentrantCounter = 0;
var nonReentrant = function(default_value, fn) {
  var id = nonReentrantCounter++;
  return function() {
    if (!this.reentrancy_state) this.reentrancy_state=[];
    if (this.reentrancy_state[id]) {
      console.log("reentrant on " + str(this) + ", returning default");
      return default_value;
    }
    this.reentrancy_state[id] = true;
    try {
      return fn.apply(this, arguments);
    } finally {
      this.reentrancy_state[id] = false;
    }
  }
}

var _scope_ctr = 1;
function Scope(parent, pctx) {
  this._id = _scope_ctr++;
  this._parent = parent;
  this.variables = {};
  this.stmts = [];
  this.children = [];
  this.pctx = pctx;
  this.identifiers = [];
  this._this_var = new Variable('this', this);
  if (parent) parent.children.push(this);
};
Scope.prototype.toString = function() {
  return "Scope#" + this._id + "(" + str(this.variables) + ")";
}
Scope.prototype.add_ident = function(ident) {
  // when we generate an identifier, we don't know how it'll be used.
  // We store it on the current `scope`, and when each scope is
  // complete we turn unused identifiers into variable references
  this.identifiers.push(ident);
};

Scope.prototype.convert_unused_identifiers_into_references = function(stmt) {
  for (var i=0; i<this.identifiers.length; i++) {
    var ident = this.identifiers[i];
    if (!ident.used) {
      console.log("turning otherwise-unused Id into variable reference: " + ident);
      this.get_var(ident.name);
      console.log("and now current_stmt= " + str(this.pctx.current_stmt));
      console.log("and now current_stmt.references = " + str(this.pctx.current_stmt.references));
    } else {
      console.log("ident was used: " + str(ident));
    }
  }
  this.identifiers = [];
}

Scope.prototype.add_var = function(name) {
  if (name instanceof ObjectLit) {
    // destructuring object
    for (var i = 0; i<name.props; i++) {
      this.add_var(name.props[i][1]);
    }
    return;
  } else if (name instanceof ArrayLit) {
    // destructuring array
    for (var i=0; i<name.arr.length; i++) {
      this.add_var(name.arr[i]);
    }
    return;
  } else if (name instanceof Id) {
    name.use();
    name = name.name;
  }
  if (typeof(name) !== 'string') {
    throw new Error("weird name: " + str(name) + " // " + typeof(name));
  }

  if(Object.prototype.hasOwnProperty.call(this.variables, name)) {
    // console.warn("variable defined twice: " + name); // XXX
    return this.variables[name];
  }

  var ident = new Variable(name, this)
  this.variables[name] = ident;
  console.log("VARIABLE: " + name + " // " + this);
  return ident;
};
Scope.prototype.get_var = function(v, direct) {
  assert(typeof(v) === 'string', "non-string variable: " + v);
  if (v === 'this') {
    // there's a `this` in every scope, but it doesn't affect
    // dependencies
    return this._this_var;
  }

  var variable;
  if (Object.prototype.hasOwnProperty.call(this.variables, v)) {
    variable = this.variables[v];
  } else if (this._parent) {
    variable = this._parent.get_var(v, true);
  } else {
    // console.warn("global variable reference: " + v); // XXX
    variable = this.add_var(v);
  }

  if (direct) {
    return variable;
  }

  // `direct` means access the variable (for internal use),
  // but default use gets a reference to the given variable
  console.log("ref() from get_var");
  return new Ref(variable, this.pctx);
};

function ModuleReference(arg, path) {
  this.arg = assert(arg, "null arguments given to ModuleReference");
  assert(Array.isArray(path), "empty path given to ModuleReference");
  this.path = path;
};
ModuleReference.prototype.toString = function() {
  return "ModuleReference(" + str(this.arg) + ", " + str(this.path) + ")";
};

function SelfReference() { };
SelfReference.prototype.is_self = true;
SelfReference.prototype.toString = function() {
  return "SelfReference()";
};

function tapLog(desc, val) {
  console.log(desc, val);
  return val;
}

var process_script = function(pctx) {
  var scope = current_scope(pctx);
  var stmts = seq(scope.stmts);
  // console.log(stmts.flatten());
  // console.log(str(scope));
  return {
    requires: stmts.flatten(),
    toplevel: scope,
  };
}

var seq = function(exprs) {
  var r = Dynamic;
  for (var i=0; i<exprs.length; i++) {
    if (exprs[i]) r = r.seq(exprs[i]);
  }
  return r;
}

// Generic Data types:

var Maybe = function(x) { return x === undefiend ? Nothing() : Just(x); };

var Just = function(x) {
  return {
    defined: function() { return true; },
    map: function(f) { return Just(f(x)); },
    bind: function(f) { return f(x); },
    get: function() { return x; },
    getLazy: function(_) { return x; },
    orElse: function(_) { return this; },
    toString: function () { return "Just(" + str(x) + ")"; },
  };
};

var Nothing = function() {
  return {
    defined: function() { return false; },
    map: function() { return this; },
    get: function(d) { return d; },
    getLazy: function(fn) { return fn(); },
    bind: function(d) { return this; },
    orElse: function(d) { return d; },
    toString: function() { return "Nothing()"; },
  };
};

var map = function(arr, fn) {
  // [a] -> (a -> b) -> [b]
  var res = [];
  for (var i=0; i<arr.length; i++) {
    res[i] = fn(arr[i]);
  }
  return res;
}
var mapM = function(arr, fn) {
  // [Maybe a] -> (a -> b) -> [Maybe b]
  var res = [];
  for (var i=0; i<arr.length; i++) {
    res[i] = arr[i].map(fn);
  }
  return res;
}

var flattenM = function(arr) {
  // [Maybe a] -> Maybe [a]
  var ret = [];
  for (var i=0; i<arr.length; i++) {
    if (!(arr[i].defined())) { return Nothing(); }
    ret[i] = arr[i].get();
  }
  return Just(ret);
}

var filterM = function(arr) {
  // [Maybe a] -> [a]
  var ret = [];
  for (var i=0; i<arr.length; i++) {
    if (arr[i] instanceof Nothing) continue;
    ret[i] = arr[i].get();
  }
  return ret;
}

var flattenAnyM = function(arr) {
  // [Maybe a] -> Maybe [a|undefined]
  var any = false;
  var ret = [];
  for (var i=0; i<arr.length; i++) {
    if (!any && arr[i].defined()) {
      any = true;
    }
    ret[i] = arr[i].get(undefined);
  }
  return any ? Just(ret) : Nothing();
};

var concat = function(arr) {
  var rv = [];
  for (var i=0; i<arr.length; i++) {
    rv = rv.concat(arr[i]);
  }
  return rv;
};


// Minimal AST
//
// Static(x) represents a dependency that will definitely occur in the given scope
// (e.g "this module WILL require ./mod2").
//
// Dynamic(x) represents an upper bound of the dependency-relevant information
// in a given scope (e.g the symbol "foo" may be used, and it may come from
// either "./mod1" or "./mod2").

var applyScope = (function() {
  return function(obj, scope) {
    assert(typeof(scope) === 'string' || scope === null, "not a string: " + scope);
    if (!obj.exportScope) obj.exportScope = [];
    // assert(obj.exportScope === undefined, "can't scope " + obj + " to " + scope + " - already scoped to " + obj.exportScope);
    console.log("SCOPE(" + str(scope) + "): " + str(obj));
    obj.exportScope.push(scope);
  };
})();

// Dynamic also serves as the base for other syntax types:
var Dynamic = {
  // combinators
  seq: function(other) { return other; },
  dot: function(prop) { return Dynamic; },
  call: function(args) { return new Call(this, args); },

  // scope:
  exportScope: undefined,

  // values
  staticValue: Nothing,                 // statically-determined value (an eval()-able string)
  possibleValues: function() {          // default to just this.staticValue()
    console.log("default possibleValues of " + str(this));
    var rv = this.staticValue().map(function(val) { return [val]; }).get([]);
    console.log("got default possibleValues :" + str(rv));
    return rv;
  },
  // text: Nothing,                        // source code representation
  flatten: function() { return []; },   // Return all non-dynamic children
  toString: function() { return "Dynamic()"; },
};

function Block(scope) {
  this.scope = scope;
};
Block.prototype = Object.create(Dynamic);
Block.prototype.merge = false; // merge with parent block upon completion
Block.prototype.toString = function() {
  return "Block{"+str(this.scope)+"}";
};


var Property = function(parent, text, pctx) {
  this.parent = parent;
  this.name = text;
  this.children = {};
  this.values = [];
}
Property.prototype = Object.create(Dynamic);
Property.prototype.staticValue = function() {
  var self = this;
  return this.parent.staticValue().map (function(val) {
    return val + "." + self.name;
  });
};
Property.prototype.toString = function() {
  return str(this.parent) + "." + this.name;
}
// Identifier
var __id_ctr = 0;
var Id = function(text, scope) {
  this.name = text;
  this.scope = scope;
  this.used = false;
  this._ctr = __id_ctr++;
  console.log("INIT ID: " + str(this));
};
Id.prototype = Object.create(Dynamic);
Id.prototype.toString = function() { return "Id#" + this._ctr + "(" + this.name + ")"; };
Id.prototype.use = function() {
  // mark this identifier as "used". At the end of each toplevel
  // stmt, we assume all unused identifiers are actually
  // reference expressions
  this.used = true;
};

// delegate `dot`, `assign`, etc to underlying variable
;['dot','assign', 'call', 'possibleValues','staticValue'].forEach(function(method) {
  Id.prototype[method] = function() {
    this.use();
    var variable = this.scope.get_var(this.name);
    return variable[method].apply(variable, arguments);
  };
});

var Variable = function(text, scope) {
  this.name = text;
  this.scope = scope;
  this.export_scope = null;
  this.values = [];
  this.children = {};
  this.provides = [this];
  // console.log("ID: " + this, this.scopes);
};
Variable.prototype = Object.create(Dynamic);
Variable.prototype.staticValue = function() {
  console.log("TODO: Variable.staticValue" + str(this));
  return Nothing();
};

Variable.prototype.possibleValues = nonReentrant([], function() {
  // just like staticValues, but produces an
  // array of possible alternatives
  console.log("getting possible values from Variable " + this);
  console.log("value ASTs = " + str(this.values));
  var possible = this.values.map(function(v) {
    console.log("variable traversal: possible values of " + str(v) + " = " + str(v.possibleValues()));
    return v.possibleValues();
  });
  return concat(possible);
});

Variable.prototype.dot = Property.prototype.dot = function(name) {
  if (!has(this.children, name)) {
    this.children[name] = new Property(this, name);
  }
  return assert(this.children[name]);
};

Variable.prototype.assign = Property.prototype.assign = function(value) {
  console.log(str(this) + " assuming value: " + str(value));
  this.values.push(value);
};

Variable.prototype.toString = function() { return "Variable[#" + this.scope._id + "](" + this.name + ")"; };

var Ref = function(dest, pctx) {
  assert(dest, "Ref created with empty destination!");
  while(dest instanceof Ref) {
    dest = dest.dest;
  }
  this.dest = dest;
  this.pctx = pctx;
  pctx.current_stmt.add_reference(this);
};
Ref.prototype = Object.create(Dynamic);

Ref.prototype.call = function(args) {
  console.log("REF from call: " + str(this.dest));
  var call = this.dest.call(args, this.pctx);
  return new Ref(call, this.pctx);
};

Ref.prototype.staticValue = function() {
  return this.dest.staticValue();
};

Ref.prototype.possibleValues = function() {
  return this.dest.possibleValues();
};

Ref.prototype.deref = function() {
  this.pctx.current_stmt.remove_reference(this);
};

Ref.prototype.dot = function(name) {
  // since references are not shared, dotting a reference must mean
  // that the code _only_ accesses <foo>.prop, and not <foo> itself.
  var underlying = this.dest.dot(name);
  this.deref();
  console.log("REF from dot: " + str(underlying));
  return new Ref(underlying, this.pctx);
};

Ref.prototype.assign = function(value) {
  console.log("ASSIGNING TO " + this);
  return this.dest.assign(value);
};
Ref.prototype.toString = function() { return "Ref(" + this.dest + ")"; };


var Statement = function() {
  this.references = [];
  this.dependencies = [];
  this.moduleDependencies = [];
  this.stmt = null;
}
Statement.prototype = Object.create(Dynamic);
Statement.prototype.toString = function() {
  return 'Stmt{'+str(this.stmt) +'}';
};
Statement.prototype.add_reference = function(ref) {
  console.log("+REF: " + ref);
  this.references.push(ref);
};
Statement.prototype.remove_reference = function(ref) {
  console.log("+UNREF: " + ref);
  var idx = this.references.indexOf(ref);
  if (idx === -1) {
    console.log("Can't find reference: " + ref + " in list: " + str(this.references));
    // throw new Error("Can't find reference: " + ref + " in list: " + str(this.references));
  }
  this.references.splice(idx, 1);
};
Statement.prototype.set = function(stmt) {
  if (this.stmt) throw new Error("Can't re-assign " + this.stmt + " to " + stmt);
  console.log("Setting stmt to " + str(stmt));
  this.stmt = stmt;
};

Statement.prototype.calculateDependencies = function(toplevel) {
  this.calculateDirectDependencies(toplevel);
  // this.expandDependencies();
};

function determineModuleReferences(node, path) {
  var seen = [];
  var inner = function(node, path) {
    if (seen.indexOf(node) !== -1) {
      console.log("CYCLIC NODE: " + str(node));
      return [];
    }
    seen.push(node);
    var module = null;
    path = path ? path.slice() : [];

    console.log("Checking reference " + node +", path = " + str(path));
    while(true) {
      if (this.is_exports(node) && path.length == 0) {
        console.log("raw EXPORTS reference!");
        return [new SelfReference()];
      }

      if (node instanceof Property) {
        // keep traversing parent
        path.unshift(node.name);
        node = node.parent;
      } else if (node instanceof Call) {
        console.log("Checking call of: " + node.expr);
        if (node.expr === this.require && node.args.length > 0) {
          var arg = node.args[0];
          var alternatives = arg.possibleValues();
          if (alternatives.length > 0) {
            console.log("Checking all possible argument values:" + str(alternatives));
            return alternatives.map(function(arg) {
              var moduleRef = new ModuleReference(arg, path);
              console.log("yup! require call:" + moduleRef);
              return moduleRef;
            });
          } else {
            console.log("NOT Checking all possible argument values (there are none):" + str(arg));
            return [];
          }
        } else {
          // not a require call - but maybe a property of some required module:
          path = [];
          node = node.expr;
        }
      } else if (node instanceof Variable) {
        var rv = [];
        for (var valIdx = 0; valIdx < node.values.length; valIdx++) {
          console.log("traversing variable " + node + " value: " + node.values[valIdx]);
          rv = rv.concat(inner.call(this, node.values[valIdx], path));
        }
        return rv;
      } else {
        console.log("unknown thing! " + node);
        module = null;
        return [];
      }
    }
  };
  return inner.apply(this, arguments);
};

Statement.prototype.calculateDirectDependencies = function(toplevel) {
  var stmts = toplevel.stmts;
  
  // statement dependencies:
  for (var i = 0; i < stmts.length; i++) {
    var stmt = stmts[i];
    if(stmt === this) continue;
    var provides = stmt.stmt.provides;
    console.log("Checking for dependency on " + str(stmt) + " which provides " + str(provides));
    if (!provides) continue;

    for (var p = 0; p<provides.length; p++) {
      var provided = provides[p];
      if (toplevel.is_exports(provided)) {
        console.log("Stmt " + stmt + " provides module.exports - adding self-reference");
        this.moduleDependencies.push(new SelfReference());
      }
    }

    for (var r = 0; r<this.references.length; r++) {
      var needed = this.references[r].dest;
      while(true) {
        if (provides.indexOf(needed) !== -1) {
          console.log("stmt " + this + " depends on " + stmt + " because " + str(needed));
          if (this.dependencies.indexOf(stmt) == -1) {
            this.dependencies.push(stmt);
          }
        }
        if (needed instanceof Property) {
          // if we depend on `foo.bar`, we also depend
          // on any statement that provides `foo`
          needed = needed.parent;
        } else {
          break;
        }
      }
    }
  }

  // module dependencies:
  for (var i = 0; i < this.references.length; i++) {
    var node = this.references[i].dest;
    console.log("Adding module references from " + this.references[i]);
    this.moduleDependencies = this.moduleDependencies.concat(
        toplevel.determineModuleReferences(node));
  }
};

var MultipleStatements = function(stmts) {
  this.stmts = stmts;
};
MultipleStatements.prototype = Object.create(Dynamic);
MultipleStatements.prototype.toString = function() {
  return "MultipleStatements" + str(this.stmts);
}
MultipleStatements.wrap = function(stmts) {
  if (stmts.length == 1) {
    return stmts[0];
  }
  return new MultipleStatements(stmts);
}

var Assignment = function(l, op, r, pctx) {
  this.left = l;
  this.op = op;
  this.right = r || Dynamic;
  var scope = current_scope(pctx);
  var provides = [];
  if (r instanceof Assignment) {
    // `x = y = z` provides both x & y
    provides = r.provides.slice();
  }
  provides.push(l);
  this.provides = provides;

  var isAssignment = op === '=';
  if (isAssignment) {
    console.log("Assigning " + str(l) + " = " + str(r));
    l.assign(r);
  }
}
Assignment.prototype = Object.create(Dynamic);
Assignment.prototype.toString = function() {
  return "Assignment(" + str(this.left) + " " + this.op + " " + str(this.right) + ")";
}
Assignment.prototype.staticValue = function() { return this.right.staticValue(); };

function expand_assignment(is_var, l, op, r, pctx, stmts) {
  // turn a single assignment into one or more primitive Assignment statements
  stmts = stmts || [];
  console.log("expanding assignment " + str(l) + str(op) + str(r));
  var scope = current_scope(pctx);
  var isAssignment = op === '=';

  var provide = function(l, r) {
    console.log("providing: " + str(l));
    if (!r) return; // just `var x`, not `var x = <exr>`
    if (l instanceof Id) {
      if (is_var) {
        l = current_scope(pctx).add_var(l.name);
      } else {
        l = current_scope(pctx).get_var(l.name, true /* don't wrap in a reference */);
      }
    }

    if (r instanceof Ref) {
      // plain assignments don't count as a use - `r` is only used when
      // `l` gets referenced / dotted / called
      r.deref();
      r = r.dest;
    }
    if (l instanceof Ref) {
      l.deref();
      l = l.dest;
    }

    if (l instanceof Variable || l instanceof Property) {
      stmts.push(new Assignment(l, op, r, pctx));
    } else if (l instanceof ObjectLit) {
      for (var i=0; i<l.props.length; i++) {
        var par = l.props[i];
        assert(par.length === 2);
        var _l = par[1];
        var _r = par[0];
        assert(_r instanceof Id, "Unexpected RHS in destructure pattern: " + _r);
        _r = r.dot(_r.name);
        console.log("Assigning " + _l + " -> " + _r);
        provide(_l, _r);
      }
    } else if (l instanceof ArrayLit) {
      for (var i=0; i<l.arr.length; i++) {
        var _l = l.arr[i];
        var _r = Dynamic;
        // if rhs is an arrayLit as well, we can actually associate
        // l & r pairs
        if (r instanceof ArrayLit) {
          _r = r.arr[i] || new Lit("undefined");
        }
        provide(_l, _r);
      }
    } else {
      console.log("Don't know how to provide lvalue: " + l);
    }
  }
  provide(l,r);
  console.log("compound assignment " + str(stmts));
  return stmts;
}

// A sequence of AST nodes (well, just two - successive sequences form a stick)
var Seq = function(a,b) {
  this.a = a;
  this.b = b;
  // console.log(" # " + this);
};
Seq.prototype = Object.create(Dynamic);
Seq.prototype.seq = function(other) { return new Seq(this, other); };

/* calls apply to the second object in a seq */
Seq.prototype.call = function() { return new Seq(this.a, this.b.call.apply(this.b, arguments)); };
Seq.prototype.flatten = function() { return this.a.flatten().concat(this.b.flatten()); };
Seq.prototype.toString = function() { return "Seq(" + this.a + "," + this.b + ")"; };

// A function call
var Call = function(expr, args) {
  this.expr = expr;
  this.args = args;
  this.capturePossibleValues();
};
Call.prototype = Object.create(Dynamic);
Call.prototype.seq = function(other) { return new Seq(this, other); };
Call.prototype.dot = function(property) {
  return new Property(this, property);
};

Call.prototype.capturePossibleValues = function() {
  // capture possible values at expression parse time, in order
  // to better resolve cyclical values
  var expr = this.expr;
  if (expr instanceof Ref) expr = assert(expr.dest);
  if (expr instanceof Property) {
    this._possibleSubjects = expr.parent.possibleValues();
    console.log("captured _possibleSubjects of: " + str(this._possibleSubjects) + " from " + str(expr.parent));
    this._possibleArgs = this.args.map(function(arg) { return arg.possibleValues(); });
    this._expr = this.expr;
  }
};

Call.prototype.possibleValues = nonReentrant([], function() {
  // XXX we're only implementing enough here to be useful
  // to the typical use case of concatenating array literals
  var rv = [];
  
  console.log("determining possible values of some method " + str(this));
  console.log("expr is " + str(this.expr));
  console.log("its parent is " + str(this.expr.parent));
  var expr = this._expr;
  if (expr) {
    console.log("determining possible values of method " + str(this));
    var possibleSubjects = this._possibleSubjects;
    console.log("possibleSubjects from " + str(expr.parent) + " are: " + str(possibleSubjects));

    for (var subji=0;subji<possibleSubjects.length;subji++) {
      var subject = possibleSubjects[subji];
      if (!Array.isArray(subject)) {
        console.log("Skipping non-array subject: " + str(subject));
        continue;
      }
      var method = Array.prototype[expr.name];
      if (!method) {
        console.log("can't statically resolve array method " + expr.name);
        continue;
      }
      // generate a cross-product of all possible values of all arguments
      var argPossibilities = this._possibleArgs;
      if (argPossibilities.length != 1) {
        console.log("XXX implement multile arguments");
        continue;
      }

      var possibleValues = argPossibilities[0];
      console.log("argPossibilities = " + str(possibleValues));
      for (var i=0; i<possibleValues.length; i++) {
        try {
          var copy = subject.slice();
          var result = method.call(copy, possibleValues[i]);
          if (result) {
            rv.push(result);
          }
        } catch(e) {
          console.log("error statically resolving " + str(this) + ":\n" + e + "\n" + e.stack);
        }
      }
    }
  }
  console.log("possible value: -> " + str(rv));
  return rv;
});

Call.prototype.staticArgs = function() {
  // returns Maybe [staticValue]
  var args = this.args;
  var static_args = [];
  for (var i=0; i<args.length; i++) {
    static_args[i] = args[i].staticValue();
  }
  return flattenAnyM(static_args);
};

Call.prototype.flatten = function() {
  var prop = this.prop;
  var static_args = this.staticArgs();
  return tapLog('ARG_FLAT:', prop.staticValue().bind(function(ident) {
    console.log("IDENT " + ident);
    switch(ident) {
      case "require":
        return Just({call: "require", args: static_args});
        break;
      case "require.hubs.unshift":
        return Just({call:"hub_insert", args: static_args});
        break;
      case "require.hubs.push":
        return Just({call:"hub_append", args: static_args});
        break;
      default: return Nothing();
    }
  }).getLazy(function() {
    // this isn't a require call, but our args will
    // always be evaluated, and they might contain
    // require()s
    return seq(static_args).flatten();
  }));
};
Call.prototype.toString = function() { return "Call(" + this.expr + "," + this.args + ")"; };

// A primitive literal
var Lit = function(val) {
  this.val = val;
  // console.log(" # " + this);
};
Lit.prototype = Object.create(Dynamic);
Lit.prototype.staticValue = function() { return Just(eval(this.val)); };
Lit.prototype.toString = function() { return "Literal(" + this.staticValue() + ")"; };


// an Array literal
var ArrayLit = function(arr) {
  this.arr = arr;
  // console.log(" # " + this);
};
ArrayLit.prototype = Object.create(Dynamic);
ArrayLit.prototype.staticValue = function() {
  var arr = this.arr;
  if (arr.length == 0) return Just([]);
  var maybeVals = [];
  for (var i=0; i<arr.length; i++) {
    maybeVals[i] = arr[i].staticValue();
  }
  return flattenAnyM(maybeVals);
};
ArrayLit.prototype.toString = function() {
  var join = function(vals) { return vals.join(","); };
  return "ArrayLit" + str(this.arr);
};

// an Object literal
var ObjectLit = function(spec, pctx) {
  var props = this.props = [];
  var scope = current_scope(pctx);

  for (var i=0; i<spec.length; ++i) {
    var def = spec[i];
    def[1] = new Id(def[1], scope);
    if (def[0] == "prop") {
      props.push([def[1], def[2]]);
    } else if (def[0] == "pat") {
      var value = def[1];
      var key = def[2];
      if (def.length == 3) {
        // shorthand "prop" for "prop:prop"
        key = def[1];
      }
      props.push([key, value]);
    }
  }
  console.log("GEN_OBJ_LIT: " + str(props));
  // console.log(" # " + this);
}
ObjectLit.prototype = Object.create(Dynamic);
ObjectLit.prototype.staticValue = function() {
  var props = this.props;
  var obj = {};
  for (var i=0; i<props.length; i++) {
    var elem = props[i];
    var key = elem[0];
    if (key instanceof Id) {
      key = key.name;
    } else {
      continue;
    }
    elem[1].staticValue().map(function(v) {
      obj[key] = v;
    });
  }
  return Just(obj);
};
ObjectLit.prototype.toString = function() { return "ObjectLit(" + str(this.props) + ")"; };


function init_toplevel(pctx) {
  var GlobalScope = new Scope(null, pctx);
  var PredefinedModuleScope = new Scope(GlobalScope, pctx);
  var ModuleScope = new Scope(PredefinedModuleScope, pctx);

  function constant(name) {
    var v = PredefinedModuleScope.add_var(name);
    return v;
  };
  ModuleScope.top = ModuleScope;
  ModuleScope.require = constant('require');
  ModuleScope.module = constant('module');

  var export_expressions = [constant('exports'), ModuleScope.module.dot('exports')];

  // __oni_altns should be considered part of module scope, unlike
  // exports / module / require which sit above it
  ModuleScope.add_var('__oni_altns');

  ModuleScope.is_exports = function(expr) {
    return export_expressions.indexOf(expr) !== -1;
  };
  ModuleScope.determineModuleReferences = determineModuleReferences;
  pctx.scopes = [ModuleScope];
  pctx.current_stmt = new Statement();
  pctx.stmt_index = 0;
};

function push_scope(pctx) {
  console.log("++ SCOPE");
  var parent = current_scope(pctx);
  var scope;
  if (pctx.suppress_next_block) { // TODO: use MultipleStatements block instead?
    // hack: duplicate current scope so that
    // it's effectively merged, and
    // pop_scope doesn't freak out
    delete pctx.suppress_next_block;
    scope = parent;
  } else {
    scope = new Scope(parent, pctx);
    scope.top = pctx.scopes[0];
  }
  pctx.scopes.push(scope);
  return scope;
}

function pop_scope(pctx) {
  var scope = pctx.scopes.pop();
  scope.convert_unused_identifiers_into_references();
  console.log("-- SCOPE");
  return scope;
}

function add_stmt(stmt, pctx) {
  var scope = current_scope(pctx);
  var top = scope.top === scope;
  function _add_stmt(stmt) {
    if (!stmt) {
      console.warn("NUll stmt: " + stmt);
      return;
    }

    if (stmt instanceof MultipleStatements) {
      console.log("add_stmt expanding MultipleStatements: " + stmt);
      stmt = stmt.stmts;
    }

    if(Array.isArray(stmt)) {
      console.log("Adding " + stmt.length + " statements");
      for (var i=0;i<stmt.length;i++) {
        // NOTE: we give the same index to multiple toplevel assignments, because
        // they all come from the same statement (even though we track
        // them separately for dependency reasons)
        _add_stmt(stmt[i]);
      }
      return;
    }
    if (top) {
      var container = pctx.current_stmt;
      container.set(stmt);
      scope.convert_unused_identifiers_into_references();
      pctx.current_stmt = new Statement();
      var seen = [];

      function add_scope_from(stmt) {
        if (seen.indexOf(stmt) !== -1) {
          // recursive invocation
          return;
        }
        seen.push(stmt);
        if (stmt instanceof Assignment) {
          console.log("Assignment to: " + str(stmt.provides));
          for (var p = 0; p<stmt.provides.length; p++) {
            var provided = stmt.provides[p];
            var root = provided;
            console.log("root : " + root);
            var prop = null;
            if (root instanceof Property) {
              while(root instanceof Property) {
                if (scope.is_exports(root)) break; // don't progress up past exports
                prop = root.name;
                root = root.parent;
              }
            }
            if (scope.is_exports(root)) {
              applyScope(container, prop ? 'exports.' + prop : null);
            } else {
              add_scope_from(root);
            }
          }
        } else if (stmt instanceof Variable) {
          if (stmt.scope === scope) {
            // toplevel var: apply this scope
            applyScope(container, assert(stmt.name));
          }

          // also apply any scopes adopted by its values
          for (var vali=0; vali<stmt.values.length; vali++) {
            add_scope_from(stmt.values[vali]);
          }
        } else {
          return false;
        }
        return true;
      }
      var added = add_scope_from(stmt, true);
      if (!added) {
        // default to toplevel scope
        console.log("Non-assignment: " + stmt);
        applyScope(container, null);
      }

      stmt = container;
      console.log("TOPLEVEL STMT: " + stmt);

      if (stmt.exportScope === undefined) {
        // all toplevel statements have a global exportScope by default
        applyScope(stmt, null);
      }
    }
    stmt.index = pctx.stmt_index;
    scope.stmts.push(stmt);
  };
  _add_stmt.call(this, stmt);
};

function current_scope(pctx) {
  return pctx.scopes[pctx.scopes.length-1];
}



//----------------------------------------------------------------------
// misc:

#define HANDLE_NEWLINES(n, pctx) /* */
  
//----------------------------------------------------------------------
// contexts:

#define BEGIN_SCRIPT(pctx)                                   \
  if (typeof pctx.scopes !== 'undefined')                    \
    throw new Error("Internal parser error: Nested script"); \
  pctx.export_scopes = {};                                   \
  init_toplevel(pctx);

#define ADD_SCRIPT_STMT(stmt, pctx) add_stmt(stmt, pctx); pctx.stmt_index++;

#define END_SCRIPT(pctx)                        \
  return process_script(pctx);

#define BEGIN_FBODY(pctx,dummy) push_scope(pctx);

#define ADD_FBODY_STMT(stmt, pctx) add_stmt(stmt, pctx);

// XXX should we distinguish fbody block from standard block, to e.g
// treat statements as toplevel even when they appea under if(hostenv === 'xbrowser') { ... }

#define END_FBODY(pctx,dummy) console.log("END_FBODY: " + str(current_scope(pctx))); pop_scope(pctx); return Dynamic;

#define BEGIN_BLOCK(pctx) push_scope(pctx);

#define ADD_BLOCK_STMT(stmt, pctx) add_stmt(stmt, pctx);

#define END_BLOCK(pctx) console.log("END_BLOCK: " + str(current_scope(pctx))); return new Block(pop_scope(pctx));

#define BEGIN_CASE_CLAUSE(cexp, pctx) /* */

#define ADD_CASE_CLAUSE_STMT(stmt, pctx) /* */

#define END_CASE_CLAUSE(pctx) /* */

#define BEGIN_LOOP_SCOPE(pctx)   /* */
#define END_LOOP_SCOPE(pctx)     /* */
#define BEGIN_SWITCH_SCOPE(pctx) /* */
#define END_SWITCH_SCOPE(pctx)   /* */


#define BEGIN_BLAMBDABODY(pctx) /* */

#define ADD_BLAMBDABODY_STMT(stmt, pctx) /* */

#define END_BLAMBDABODY(pctx) return Dynamic;


//----------------------------------------------------------------------
// statements:
#define GEN_EMPTY_STMT(pctx) return Dynamic;

#define GEN_EXP_STMT(exp, pctx) return exp;

#define GEN_LBL_STMT(lbl, stmt, pctx) return stmt;

#define GEN_FUN_DECL(fname, pars, body, pctx) \
  var v = current_scope(pctx).add_var(fname); \
  return new Assignment(v, '=', body, pctx);

#define GEN_VAR_DECL(decls, pctx)                                        \
  var stmts=[];                                                          \
  for (var i=0; i<decls.length; ++i) {                                   \
    console.log("GEN_VAR " + str(decls[i][0]));                          \
    current_scope(pctx).add_var(decls[i][0]);                            \
    expand_assignment(true, decls[i][0], '=', decls[i][1], pctx, stmts); \
  };                                                                     \
  return MultipleStatements.wrap(stmts);

#define GEN_IF(test, consequent, alternative, pctx) \
  var stmts = [];                                   \
  if (consequent instanceof Block) {                \
    stmts = stmts.concat(consequent.scope.stmts);   \
  } else {                                          \
    stmts.push(consequent);                         \
  }                                                 \
  if (alternative instanceof Block) {               \
    stmts = stmts.concat(alternative.scope.stmts)   \
  } else {                                          \
    stmts.push(alternative);                        \
  }                                                 \
  console.log("GEN_IF:" + str(stmts));         \
  return MultipleStatements.wrap(stmts);

#define GEN_DO_WHILE(body, test, pctx) return Dynamic;

#define GEN_WHILE(test, body, pctx) return Dynamic;

#define GEN_FOR(init_exp, decls, test_exp, inc_exp, body, pctx) return Dynamic;

#define GEN_FOR_IN(lhs_exp, decl, obj_exp, body, pctx) return Dynamic;

#define GEN_CONTINUE(lbl, pctx) return Dynamic;

#define GEN_BREAK(lbl, pctx) return Dynamic;

#define GEN_RETURN(exp, pctx) return exp;

#define GEN_WITH(exp, body, pctx) return body;

#define GEN_SWITCH(exp, clauses, pctx) return Dynamic;

#define GEN_THROW(exp, pctx) return Dynamic;

function gen_crf(crf) {
  var rv = Dynamic;
  if (crf[2])
    rv = rv.seq(crf[2]);
  return rv;
}

#define GEN_TRY(block, crf, pctx) return block.seq(gen_crf(pctx));

//----------------------------------------------------------------------
// expressions:

#define GEN_INFIX_OP(left, id, right, pctx) return right;
#define GEN_ASSIGN_OP(left, id, right, pctx) \
  console.log("ASSIGN_OP", str(left), id, str(right)); \
  return MultipleStatements.wrap(expand_assignment(false, left, id, right, pctx));
#define GEN_PREFIX_OP(id, right, pctx) return right;
#define GEN_POSTFIX_OP(left, id, pctx) return left;

#ifdef SJS_ARROWS
#define GEN_THIN_ARROW(body, ptcx) return Dynamic;
#define GEN_THIN_ARROW_WITH_PARS(pars, body, pctx) return Dynamic;
// note the intentional space in ' =>' below; it is to fix cases like '= => ...'
#define GEN_FAT_ARROW(body, ptcx) return Dynamic;
#define GEN_FAT_ARROW_WITH_PARS(pars, body, pctx) return Dynamic;
#endif

#ifdef SJS_DOUBLEDOT
#define GEN_DOUBLEDOT_CALL(l,r,pctx) return l.seq(r);
#endif

#ifdef SJS_ALTERNATE_NAMESPACE
#define GEN_ALTERNATE_NAMESPACE_OBJ(pctx) console.log("@NS plain"); return current_scope(pctx).get_var("__oni_altns");
#define GEN_ALTERNATE_NAMESPACE_IDENTIFIER(value, pctx) console.log("@NS IDENT"); return current_scope(pctx).get_var("__oni_altns").dot(value);
#endif

#define GEN_LITERAL(type, value, pctx) return new Lit(value);

#ifdef INTERPOLATING_STRINGS
#define GEN_INTERPOLATING_STR(parts, pctx) return Dynamic;
#endif /* INTERPOLATING_STRINGS */

#ifdef QUASIS
#define GEN_QUASI(parts, pctx) return Dynamic;
#endif /* QUASIS */


#define GEN_IDENTIFIER(value, pctx)               \
  var ident = new Id(value, current_scope(pctx)); \
  current_scope(pctx).add_ident(ident);           \
  return ident;

#define GEN_OBJ_LIT(props, pctx)                          \
  return new ObjectLit(props, pctx);

#define GEN_ARR_LIT(elements, pctx) return new ArrayLit(elements);

#define GEN_ELISION(pctx) return Dynamic;

#define GEN_DOT_ACCESSOR(l, name, pctx) console.log("DOTTING:"+l + "." + name);return l.dot(name);

#define GEN_NEW(exp, args, pctx) return Dynamic;

#define GEN_IDX_ACCESSOR(l, idxexp, pctx) return l.dot(idxexp);

#define GEN_FUN_CALL(l, args, pctx) console.log("CALLING:" + str(l)); return l.call(args);

#define GEN_FUN_EXP(fname, pars, body, pctx, implicit_return) console.log("FUNBOD: " + str(body)); return body;

#define GEN_CONDITIONAL(test, consequent, alternative, pctx) return Dynamic;

#define GEN_GROUP(e, pctx) return e;

#define GEN_THIS(pctx) return current_scope(pctx).get_var("this");

#define GEN_TRUE(pctx) return new Lit("true");

#define GEN_FALSE(pctx) return new Lit("false");

#define GEN_NULL(pctx) return new Lit("null");

#define GEN_WAITFOR_ANDOR(op, blocks, crf, pctx)  \
  var rv = Dynamic;                               \
  for (var i=0; i<blocks.length; ++i){            \
    rv = rv.seq(blocks[i]);                       \
  }                                               \
  return rv;

#define BEGIN_SUSPEND_BLOCK(pctx) /*nothing*/
#define END_SUSPEND_BLOCK(pctx) /*nothing*/
#define GEN_SUSPEND(has_var, decls, block, crf, pctx)  return block;
#define GEN_COLLAPSE(pctx) /* */
#define GEN_USING(has_var, lhs, exp, body, pctx)  return body;
#define BEGIN___JS_BLOCK(pctx) console.log("START JS BLOCK"); pctx.suppress_next_block = true;
#define END___JS_BLOCK(pctx) console.log("END_JS");
#define GEN___JS(body, pctx) return body;
#define GEN_BLOCKLAMBDA(pars, body, pctx) return Dynamic;


