/*
 * C1 JS/SJS->require() analysis compiler kernel  
 *
 * Part of StratifiedJS
 * http://onilabs.com/apollo
 *
 * (c) 2013 Oni Labs, http://onilabs.com
 *
 * This file is licensed under the terms of the GPL v2, see
 * http://www.gnu.org/licenses/gpl-2.0.html
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

//----------------------------------------------------------------------
// helpers:

var Object_prototype = Object.getPrototypeOf({}); // not the same as Object.prototype in nodejs sandbox
var has = function(o,k) { return Object.prototype.hasOwnProperty.call(o,k); };
var str = function(obj) {
  if (Array.isArray(obj)) {
    return "[" + obj.join(", ") + "]";
  }
  if (obj && (obj.toString === Object_prototype.toString)) {
    var pairs = [];
    for (var k in obj) {
      if (!has(obj,k)) continue;
      pairs.push(k + ": " + str(obj[k]));
    }
    return "{" + pairs.join(", ") + "}";
  }
  return String(obj);
};
var assert = function(cond, desc) { if (!cond) throw new Error(desc || "Assertion failed"); return cond };

function Scope(parent, pctx) {
  this._parent = parent;
  this.variables = {};
  this.stmts = [];
  this.children = [];
  this.pctx = pctx;
  this._this_var = new Variable('this', this);
  if (parent) parent.children.push(this);
};
Scope.prototype.toString = function() {
  return "Scope(" + str(this.variables) + ")";
}
Scope.prototype.add_var = function(name) {
  if (name instanceof ObjectLit) {
    // destructuring object
    for (var i = 0; i<name.props; i++) {
      this.add_var(name.props[i][1]);
    }
    return;
  } else if (name instanceof ArrayLit) {
    // destructuring array
    for (var i=0; i<name.arr.length; i++) {
      this.add_var(name.arr[i]);
    }
    return;
  } else if (name instanceof Id) {
    name = name.name;
  }
  if (typeof(name) !== 'string') {
    throw new Error("weird name: " + str(name) + " // " + typeof(name));
  }

  if(Object.prototype.hasOwnProperty.call(this.variables, name)) {
    console.warn("variable defined twice: " + name);
    return this.variables[name];
  }

  var ident = new Variable(name, this)
  this.variables[name] = ident;
  console.log("VARIABLE: " + name + " // " + this);
  return ident;
};
Scope.prototype.get_var = function(v) {
  assert(typeof(v) === 'string', "non-string variable: " + v);
  if (v === 'this') {
    // there's a `this` in every scope, but it doesn't affect
    // dependencies
    return this._this_var;
  }
  if (Object.prototype.hasOwnProperty.call(this.variables, v)) {
    return new Ref(this.variables[v], this.pctx);
  }
  if (this._parent) {
    return this._parent.get_var(v);
  }
  console.warn("global variable reference: " + v);
  return new Ref(this.add_var(v), this.pctx);
};

// represents a tree-shake unit - anything behind an ExportScope
// can be removed from the module output if not referenced by any used scope
function ExportScope(name) {
  this.name = name;
  this.references = []; // a list of `Variable` objects
};
ExportScope.prototype.clone = function() {
  return new ExportScope(this.name);
};
ExportScope.prototype.toString = function() {
  return "ExportScope(" + this.name + ", " + str(this.dependencies) + ")";
}

function ModuleReference(module, property) {
  this.module = module;
  this.property = property;
};
ModuleReference.prototype.toString = function() {
  return "ModuleReference(" + str(this.module) + ", " + this.property + ")";
};

function tapLog(desc, val) {
  console.log(desc, val);
  return val;
}

var process_script = function(pctx) {
  var scope = current_scope(pctx);
  var stmts = seq(scope.stmts);
  console.log(stmts.flatten());
  console.log(str(scope));
  return {
    requires: stmts.flatten(),
    toplevel: scope,
  };
}

var seq = function(exprs) {
  var r = Dynamic;
  for (var i=0; i<exprs.length; i++) {
    if (exprs[i]) r = r.seq(exprs[i]);
  }
  return r;
}

// Generic Data types:

var Maybe = function(x) { return x === undefiend ? Nothing() : Just(x); };

var Just = function(x) {
  return {
    defined: function() { return true; },
    map: function(f) { return Just(f(x)); },
    bind: function(f) { return f(x); },
    get: function() { return x; },
    getLazy: function(_) { return x; },
    orElse: function(_) { return this; },
    toString: function () { return "Just(" + x + ")"; },
  };
};

var Nothing = function() {
  return {
    defined: function() { return false; },
    map: function() { return this; },
    get: function(d) { return d; },
    getLazy: function(fn) { return fn(); },
    bind: function(d) { return this; },
    orElse: function(d) { return d; },
    toString: function() { return "Nothing()"; },
  };
};

var map = function(arr, fn) {
  // [a] -> (a -> b) -> [b]
  var res = [];
  for (var i=0; i<arr.length; i++) {
    res[i] = fn(arr[i]);
  }
  return res;
}
var mapM = function(arr, fn) {
  // [Maybe a] -> (a -> b) -> [Maybe b]
  var res = [];
  for (var i=0; i<arr.length; i++) {
    res[i] = arr[i].map(fn);
  }
  return res;
}

var flattenM = function(arr) {
  // [Maybe a] -> Maybe [a]
  var ret = [];
  for (var i=0; i<arr.length; i++) {
    if (!(arr[i].defined())) { return Nothing(); }
    ret[i] = arr[i].get();
  }
  return Just(ret);
}

var filterM = function(arr) {
  // [Maybe a] -> [a]
  var ret = [];
  for (var i=0; i<arr.length; i++) {
    if (arr[i] instanceof Nothing) continue;
    ret[i] = arr[i].get();
  }
  return ret;
}

var flattenAnyM = function(arr) {
  // [Maybe a] -> Maybe [a|undefined]
  var any = false;
  var ret = [];
  for (var i=0; i<arr.length; i++) {
    if (!any && arr[i].defined()) {
      any = true;
    }
    ret[i] = arr[i].get(undefined);
  }
  return any ? Just(ret) : Nothing();
};


// Minimal AST
//
// Static(x) represents a dependency that will definitely occur in the given scope
// (e.g "this module WILL require ./mod2").
//
// Dynamic(x) represents an upper bound of the dependency-relevant information
// in a given scope (e.g the symbol "foo" may be used, and it may come from
// either "./mod1" or "./mod2").

var applyScope = (function() {
  var inner = function(obj, scope) {
    if (!obj.exportScope) obj.exportScope = [];
    // assert(obj.exportScope === undefined, "can't scope " + obj + " to " + scope + " - already scoped to " + obj.exportScope);
    console.log("SCOPE(" + str(scope) + "): " + str(obj));
    obj.exportScope.push(scope);
    obj.traverse(function(child) { inner(child, scope); });
  };
  return function(obj, scope) {
    assert(typeof(scope) === 'string' || scope === null, "not a string: " + scope);
    inner.apply(null, arguments);
  };
})();

// Dynamic also serves as the base for other syntax types:
var Dynamic = {
  // combinators
  seq: function(other) { return other; },
  dot: function(prop) { return Dynamic; },
  call: function(args) { return Dynamic; },

  // scope:
  exportScope: undefined,
  traverse: function(f) { },

  // values
  staticValue: Nothing,                 // statically-determined value (an eval()-able string)
  // text: Nothing,                        // source code representation
  flatten: function() { return []; },   // Return all non-dynamic children
  toString: function() { return "Dynamic()"; },
};

var Property = function(parent, text, pctx) {
  this.parent = parent;
  this.name = text;
  this.children = {};
  this.values = [];
}
Property.prototype = Object.create(Dynamic);
Property.prototype.staticValue = function() {
  var self = this;
  return this.parent.staticValue.map (function(val) {
    return val + "." + self.name;
  });
};
Property.prototype.toString = function() {
  return str(this.parent) + "." + this.name;
}

// Identifier
var Id = function(text, scope) {
  this.name = text;
  this.scope = scope;
};
Id.prototype = Object.create(Dynamic);
Id.prototype.toString = function() { return "Id(" + this.name + ")"; };

// delegate `dot`, `assign`, etc to underlying variable
;['dot','assign', 'call'].forEach(function(method) {
  Id.prototype[method] = function() {
    var variable = this.scope.get_var(this.name);
    return variable[method].apply(variable, arguments);
  };
});

var Variable = function(text, scope) {
  this.name = text;
  this.scope = scope;
  this.export_scope = null;
  this.values = [];
  this.children = {};
  this.provides = [this];
  // console.log("ID: " + this, this.scopes);
};
Variable.prototype = Object.create(Dynamic);
Variable.prototype.call = function(args) {
  var call = new Call(this, args);
  console.log("CALL: " + call);
  return call;
};
Variable.prototype.staticValue = function() {
  console.log("TODO: Variable.staticValue", this, this.values);
  return Nothing();
};

Variable.prototype.dot = Property.prototype.dot = function(name) {
  if (!has(this.children, name)) {
    this.children[name] = new Property(this, name);
  }
  return assert(this.children[name]);
};

Variable.prototype.assign = Property.prototype.assign = function(value) {
  console.log(str(this) + " assuming value: " + str(value));
  this.values.push(value);
};

Variable.prototype.toString = function() { return "Variable(" + this.name + ")"; };

var Ref = function(dest, pctx) {
  assert(dest, "Ref created with empty destination!");
  this.dest = dest;
  this.pctx = pctx;
  pctx.current_stmt.add_reference(this);
};
Ref.prototype = Object.create(Dynamic);

Ref.prototype.call = function(args) {
  console.log("REF CALL");
  var call = this.dest.call(args, this.pctx);
  return new Ref(call, this.pctx);
};

Ref.prototype.staticValue = function() {
  return this.dest.staticValue();
};

Ref.prototype.dot = function(name) {
  // since references are not shared, dotting a reference must mean
  // that the code _only_ accesses <foo>.prop, and not <foo> itself.
  var underlying = this.dest.dot(name);
  this.pctx.current_stmt.remove_reference(this);
  return new Ref(underlying, this.pctx);
};

Ref.prototype.assign = function(value) {
  console.log("ASSIGNING TO " + this);
  return this.dest.assign(value);
};
Ref.prototype.toString = function() { return "Ref(" + this.dest + ")"; };


var Statement = function() {
  this.references = [];
  this.dependencies = [];
  this.moduleDependencies = [];
  this.stmt = null;
}
Statement.prototype = Object.create(Dynamic);
Statement.prototype.toString = function() {
  return 'Stmt{'+this.stmt.toString() +'}';
};
Statement.prototype.add_reference = function(ref) {
  this.references.push(ref);
};
Statement.prototype.remove_reference = function(ref) {
  var idx = this.references.indexOf(ref);
  if (idx === -1)
    throw new Error("Can't find reference: " + ref + " in list: " + str(this.references));
  this.references.splice(idx, 1);
};
Statement.prototype.set = function(stmt) {
  if (this.stmt) throw new Error("Can't re-assign " + this.stmt + " to " + stmt);
  this.stmt = stmt;
};
Statement.prototype.traverse = function(f) {
  this.stmt.traverse(f);
};

Statement.prototype.calculateDependencies = function(toplevel) {
  this.calculateDirectDependencies(toplevel);
  // this.expandDependencies();
};

Statement.prototype.calculateDirectDependencies = function(toplevel) {
  var stmts = toplevel.stmts;
  
  // statement dependencies:
  for (var i = 0; i < stmts.length; i++) {
    var stmt = stmts[i];
    if(stmt === this) continue;
    var provides = stmt.stmt.provides;
    if (!provides) continue;
    for (var r = 0; r<this.references.length; r++) {
      var ref = this.references[r];
      if (provides.indexOf(ref.dest) !== -1) {
        // console.log("stmt " + this + " depends on " + stmt);
        // reference to a toplevel variable
        if (this.dependencies.indexOf(stmt) == -1) {
          this.dependencies.push(stmt);
        }
      }
    }
  }

  function determineModuleReferences(node, scope) {
    var module = null;
    scope = scope || null;

    console.log("Checking reference " + node);
    while(true) {
      if (node instanceof Property) {
        // keep traversing parent
        scope = node.name;
        node = node.parent;
      } else if (node instanceof Call) {
        console.log("Checking call of: " + node.expr);
        if (node.expr === toplevel.require) {
          return node.staticArgs().map(function(args) {
            console.log("yup! require call");
            return [new ModuleReference(args, scope)];
          }).getLazy(function() {
            console.log("require call with dynamic args");
            return [];
          });
        } else {
          // not a require call - but maybe a property of some required module:
          scope = null;
          node = node.expr;
        }
      } else if (node instanceof Variable) {
        var rv = [];
        for (var valIdx = 0; valIdx < node.values.length; valIdx++) {
          rv = rv.concat(determineModuleReferences(node.values[valIdx], scope));
        }
        return rv;
      } else {
        console.log("unknown thing! " + node);
        module = null;
        return [];
      }
    }
  }

  // module dependencies:
  for (var i = 0; i < this.references.length; i++) {
    var node = this.references[i].dest;
    this.moduleDependencies = this.moduleDependencies.concat(determineModuleReferences(node));
  }
};

Statement.prototype.expandDependencies = function() {
  var self = this;
  var seen = [];
  var traverse = function(stmt) {
    if (!(stmt instanceof Statement)) {
      console.log("ignoring non-stmt: " + str(stmt));
      return;
    }
    // TODO: add moduleDependencies
    for (var i=0; i<stmt.dependencies.length; i++) {
      var dep = stmt.dependencies[i];
      if (dep === self) return;
      if (seen.indexOf(dep) !== -1) return;
      seen.push(dep);
      if (self.dependencies.indexOf(dep) === -1) {
        // console.log("TRANSITIVE: " + self + " depends on " + dep);
        self.dependencies.push(dep);
      }
      traverse(dep);
    }
  }
  traverse(self);
};

var Assignment = function(l, op, r, pctx) {
  if(l instanceof Ref) {
    l = l.dest;
  }
  this.left = l;
  this.op = op;
  this.right = r || Dynamic;
  var scope = current_scope(pctx);
  var provides = this.provides = [];
  var isAssignment = op === '=';

  var provide = function(l, r) {
    console.log("providing: " + str(l));
    if (l instanceof Id) {
      l = current_scope(pctx).add_var(l.name);
    }
    if (l instanceof Variable || l instanceof Property) {
      provides.push(l);
      if (isAssignment) l.assign(r);
    } else if (l instanceof ObjectLit) {
      for (var i=0; i<l.props.length; i++) {
        var par = l.props[i];
        var key = par[1];
        console.log("GOT PAR: ", str(key));
        // var _l = par[0];
        if (par.length == 1) {
          // shorthand x -> x:x
          key = par[0];
        }
        var _r = new Property(r, key);
        provide(key, _r);
      }
    } else if (l instanceof ArrayLit) {
      for (var i=0; i<l.arr.length; i++) {
        var _l = l.arr[i];
        var _r = Dynamic;
        // if rhs is an arrayLit as well, we can actually associate
        // l & r pairs
        if (r instanceof ArrayLit) {
          _r = r.arr[i] || new Lit("undefined");
        }
        provide(_l, _r);
      }
    } else {
      console.log("Don't know how to provide lvalue: " + l);
    }
  }
  provide(l,r);
  console.log("assignment " + str(this) + " provides " + str(this.provides));
}
Assignment.prototype = Object.create(Dynamic);
Assignment.prototype.toString = function() {
  return "Assignment(" + str(this.left) + " " + this.op + " " + str(this.right) + ")";
}
Assignment.prototype.staticValue = function() { return this.right; };
Assignment.prototype.scopeTo = function(name) {
  assert(!this.exportScope, "already scoped: " + str(this));
  assert(typeof(name) === 'string', "not a string: " + name);
  this.exportScope = Some(name);
  this.right.scopeTo(name);
};

var FunctionDef = function(scope) {
  this.scope = scope;
};
FunctionDef.prototype = Object.create(Dynamic);
FunctionDef.prototype.toString = function() {
  return "Function(" + str(this.scope) + ")";
};
FunctionDef.traverse = function(f) {
  f(this.scope);
};

// A sequence of AST nodes (well, just two - successive sequences form a stick)
var Seq = function(a,b) {
  this.a = a;
  this.b = b;
  // console.log(" # " + this);
};
Seq.prototype = Object.create(Dynamic);
Seq.prototype.seq = function(other) { return new Seq(this, other); };

/* calls apply to the second object in a seq */
Seq.prototype.call = function() { return new Seq(this.a, this.b.call.apply(this.b, arguments)); };
Seq.prototype.flatten = function() { return this.a.flatten().concat(this.b.flatten()); };
Seq.prototype.toString = function() { return "Seq(" + this.a + "," + this.b + ")"; };

// A function call
var Call = function(expr, args) {
  this.expr = expr;
  this.args = args;
};
Call.prototype = Object.create(Dynamic);
Call.prototype.seq = function(other) { return new Seq(this, other); };
Call.prototype.dot = function(property) {
  return new Property(this, property);
};

Call.prototype.staticArgs = function() {
  // returns Maybe [staticValue]
  var args = this.args;
  var static_args = [];
  for (var i=0; i<args.length; i++) {
    static_args[i] = args[i].staticValue();
  }
  return flattenAnyM(static_args);
};

Call.prototype.flatten = function() {
  var prop = this.prop;
  var static_args = this.staticArgs();
  return tapLog('ARG_FLAT:', prop.staticValue().bind(function(ident) {
    console.log("IDENT " + ident);
    switch(ident) {
      case "require":
        return Just({call: "require", args: static_args});
        break;
      case "require.hubs.unshift":
        return Just({call:"hub_insert", args: static_args});
        break;
      case "require.hubs.push":
        return Just({call:"hub_append", args: static_args});
        break;
      default: return Nothing();
    }
  }).getLazy(function() {
    // this isn't a require call, but our args will
    // always be evaluated, and they might contain
    // require()s
    return seq(static_args).flatten();
  }));
};
Call.prototype.toString = function() { return "Call(" + this.expr + "," + this.args + ")"; };

// A primitive literal
var Lit = function(val) {
  this.val = val;
  // console.log(" # " + this);
};
Lit.prototype = Object.create(Dynamic);
Lit.prototype.staticValue = function() { return Just(eval(this.val)); };
Lit.prototype.toString = function() { return "Literal(" + this.staticValue() + ")"; };


// an Array literal
var ArrayLit = function(arr) {
  this.arr = arr;
  // console.log(" # " + this);
};
ArrayLit.prototype = Object.create(Dynamic);
ArrayLit.prototype.staticValue = function() {
  var arr = this.arr;
  var maybeVals = [];
  for (var i=0; i<arr.length; i++) {
    maybeVals[i] = arr[i].staticValue();
  }
  return flattenAnyM(maybeVals);
};
ArrayLit.prototype.toString = function() {
  var join = function(vals) { return vals.join(","); };
  return "ArrayLit" + str(this.arr);
};

// an Object literal
var ObjectLit = function(spec, pctx) {
  var props = this.props = [];
  var scope = current_scope(pctx);

  for (var i=0; i<spec.length; ++i) {
    var def = spec[i];
    def[1] = new Id(def[1], scope);
    if (def[0] == "prop") {
      props.push([def[1], def[2]]);
    } else if (def[0] == "pat") {
      var value = def[1];
      var key = def[2];
      if (def.length == 3) {
        // shorthand "prop" for "prop:prop"
        key = def[1];
      }
      props.push([key, value]);
    }
  }
  console.log("GEN_OBJ_LIT: " + str(props));
  // console.log(" # " + this);
}
ObjectLit.prototype = Object.create(Dynamic);
ObjectLit.prototype.staticValue = function() {
  var props = this.props;
  var obj = {};
  //XXX
  for (var i=0; i<props.length; i++) {
    var elem = props[i];
    elem[1].staticValue().map(function(v) {
      obj[elem[0]] = v;
    });
  }
  return Just(obj);
};
ObjectLit.prototype.toString = function() { return "ObjectLit(" + str(this.props) + ")"; };


function init_toplevel(pctx) {
  var GlobalScope = new Scope(null, pctx);
  var Toplevel = new Scope(GlobalScope, pctx);

  function constant(name) {
    var v = Toplevel.add_var(name);
    return v;
  };
  Toplevel.top = Toplevel;
  Toplevel.require = constant('require');
  Toplevel.exports = constant('exports');
  Toplevel.module = constant('module');
  pctx.scopes = [Toplevel];
  pctx.current_stmt = new Statement();
};

function push_scope(pctx) {
  console.log("++ SCOPE");
  var parent = current_scope(pctx);
  var scope = new Scope(parent, pctx);
  scope.top = pctx.scopes[0];
  pctx.scopes.push(scope);
  return scope;
}

function pop_scope(pctx) {
  var scope = pctx.scopes.pop();
  console.log("-- SCOPE");
  return scope;
}

function add_stmt(stmt, pctx, top) {
  if (!stmt) {
    console.warn("NUll stmt: " + stmt);
    return;
  }
  if(Array.isArray(stmt)) {
    console.log("Adding " + stmt.length + " statements");
    for (var i=0;i<stmt.length;i++) {
      add_stmt(stmt[i], pctx, top);
    }
    return;
  }
  var scope = current_scope(pctx);
  if (top) {
    var container = pctx.current_stmt;
    container.set(stmt);
    pctx.current_stmt = new Statement();

    if (stmt instanceof Assignment) {
      console.log("Assignment to: " + str(stmt.provides));
      for (var p = 0; p<stmt.provides.length; p++) {
        var provided = stmt.provides[p];
        var root = provided;
        console.log("root : " + root);
        if (root instanceof Property) {
          var prop = null;
          while(root instanceof Property) {
            prop = root.name;
            root = root.parent;
          }
          if (root === scope.exports) {
            console.log("SCOPE: " + prop);
            applyScope(container, 'exports.' + (prop || null));
          } else if (root instanceof Variable) {
            applyScope(container, root.name);
          } else {
            applyScope(container, null);
          }
        }
      }
    } else if (stmt instanceof Variable) {
      // toplevel var
      applyScope(container, stmt.name);
    } else {
      // non-assignments get toplevel scope
      console.log("Non-assignment: " + stmt);
      applyScope(container, null);
    }

    stmt = container;
    console.log("TOPLEVEL STMT: " + stmt);

    if (stmt.exportScope === undefined) {
      // all toplevel statements have a global exportScope by default
      applyScope(stmt, null);
    }
  }
  scope.stmts.push(stmt);
};

function current_scope(pctx) {
  return pctx.scopes[pctx.scopes.length-1];
}



//----------------------------------------------------------------------
// misc:

#define HANDLE_NEWLINES(n, pctx) /* */
  
//----------------------------------------------------------------------
// contexts:

#define BEGIN_SCRIPT(pctx)                                   \
  if (typeof pctx.scopes !== 'undefined')                    \
    throw new Error("Internal parser error: Nested script"); \
  pctx.export_scopes = {};                                   \
  init_toplevel(pctx);

#define ADD_SCRIPT_STMT(stmt, pctx) add_stmt(stmt, pctx, true);

#define END_SCRIPT(pctx)                        \
  return process_script(pctx);

#define BEGIN_FBODY(pctx,dummy) push_scope(pctx);

#define ADD_FBODY_STMT(stmt, pctx) add_stmt(stmt, pctx);

// XXX should we distinguish fbody block from standard block, to e.g
// treat statements as toplevel even when they appea under if(hostenv === 'xbrowser') { ... }

#define END_FBODY(pctx,dummy) console.log("END_FBODY: " + str(current_scope(pctx))); return new FunctionDef(pop_scope(pctx));

#define BEGIN_BLOCK(pctx) push_scope(pctx);

#define ADD_BLOCK_STMT(stmt, pctx) add_stmt(stmt, pctx);

#define END_BLOCK(pctx) console.log("END_BLOCK: " + str(current_scope(pctx))); pop_scope(pctx); return Dynamic;

#define BEGIN_CASE_CLAUSE(cexp, pctx) /* */

#define ADD_CASE_CLAUSE_STMT(stmt, pctx) /* */

#define END_CASE_CLAUSE(pctx) /* */

#define BEGIN_LOOP_SCOPE(pctx)   /* */
#define END_LOOP_SCOPE(pctx)     /* */
#define BEGIN_SWITCH_SCOPE(pctx) /* */
#define END_SWITCH_SCOPE(pctx)   /* */


#define BEGIN_BLAMBDABODY(pctx) /* */

#define ADD_BLAMBDABODY_STMT(stmt, pctx) /* */

#define END_BLAMBDABODY(pctx) return Dynamic;


//----------------------------------------------------------------------
// statements:
#define GEN_EMPTY_STMT(pctx) return Dynamic;

#define GEN_EXP_STMT(exp, pctx) return exp;

#define GEN_LBL_STMT(lbl, stmt, pctx) return stmt;

#define GEN_FUN_DECL(fname, pars, body, pctx) return Dynamic;

#define GEN_VAR_DECL(decls, pctx)                                 \
  var rv=[];                                                      \
  for (var i=0; i<decls.length; ++i) {                            \
    console.log("GEN_VAR " + str(decls[i][0]));                   \
    current_scope(pctx).add_var(decls[i][0], decls[i][1]);        \
    rv.push(new Assignment(decls[i][0], '=', decls[i][1], pctx)); \
  };                                                              \
  return rv;

#define GEN_IF(test, consequent, alternative, pctx) return Dynamic;

#define GEN_DO_WHILE(body, test, pctx) return Dynamic;

#define GEN_WHILE(test, body, pctx) return Dynamic;

#define GEN_FOR(init_exp, decls, test_exp, inc_exp, body, pctx) return Dynamic;

#define GEN_FOR_IN(lhs_exp, decl, obj_exp, body, pctx) return Dynamic;

#define GEN_CONTINUE(lbl, pctx) return Dynamic;

#define GEN_BREAK(lbl, pctx) return Dynamic;

#define GEN_RETURN(exp, pctx) return exp;

#define GEN_WITH(exp, body, pctx) return body;

#define GEN_SWITCH(exp, clauses, pctx) return Dynamic;

#define GEN_THROW(exp, pctx) return Dynamic;

function gen_crf(crf) {
  var rv = Dynamic;
  if (crf[2])
    rv = rv.seq(crf[2]);
  return rv;
}

#define GEN_TRY(block, crf, pctx) return block.seq(gen_crf(pctx));

//----------------------------------------------------------------------
// expressions:

#define GEN_INFIX_OP(left, id, right, pctx) return right;
#define GEN_ASSIGN_OP(left, id, right, pctx) \
  console.log("ASSIGN_OP", str(left), id, str(right)); \
  return new Assignment(left, id, right, pctx);
#define GEN_PREFIX_OP(id, right, pctx) return right;
#define GEN_POSTFIX_OP(left, id, pctx) return left;

#ifdef SJS_ARROWS
#define GEN_THIN_ARROW(body, ptcx) return Dynamic;
#define GEN_THIN_ARROW_WITH_PARS(pars, body, pctx) return Dynamic;
// note the intentional space in ' =>' below; it is to fix cases like '= => ...'
#define GEN_FAT_ARROW(body, ptcx) return Dynamic;
#define GEN_FAT_ARROW_WITH_PARS(pars, body, pctx) return Dynamic;
#endif

#ifdef SJS_DOUBLEDOT
#define GEN_DOUBLEDOT_CALL(l,r,pctx) return l.seq(r);
#endif

#ifdef SJS_ALTERNATE_NAMESPACE
#define GEN_ALTERNATE_NAMESPACE_OBJ(pctx) return current_scope(pctx).get_var("__oni_altns");
#define GEN_ALTERNATE_NAMESPACE_IDENTIFIER(value, pctx) return current_scope(pctx).get_var("__oni_altns").dot(value);
#endif

#define GEN_LITERAL(type, value, pctx) return new Lit(value);

#ifdef INTERPOLATING_STRINGS
#define GEN_INTERPOLATING_STR(parts, pctx) return Dynamic;
#endif /* INTERPOLATING_STRINGS */

#ifdef QUASIS
#define GEN_QUASI(parts, pctx) return Dynamic;
#endif /* QUASIS */


#define GEN_IDENTIFIER(value, pctx) return new Id(value, current_scope(pctx));

#define GEN_OBJ_LIT(props, pctx)                          \
  return new ObjectLit(props, pctx);

#define GEN_ARR_LIT(elements, pctx) return new ArrayLit(elements);

#define GEN_ELISION(pctx) return Dynamic;

#define GEN_DOT_ACCESSOR(l, name, pctx) console.log("DOTTING:"+l + "." + name);return l.dot(name);

#define GEN_NEW(exp, args, pctx) return Dynamic;

#define GEN_IDX_ACCESSOR(l, idxexp, pctx) return l.dot(idxexp);

#define GEN_FUN_CALL(l, args, pctx) return l.call(args);

#define GEN_FUN_EXP(fname, pars, body, pctx, implicit_return) console.log("FUNBOD: " + str(body)); return body;

#define GEN_CONDITIONAL(test, consequent, alternative, pctx) return Dynamic;

#define GEN_GROUP(e, pctx) return e;

#define GEN_THIS(pctx) return current_scope(pctx).get_var("this");

#define GEN_TRUE(pctx) return new Lit("true");

#define GEN_FALSE(pctx) return new Lit("false");

#define GEN_NULL(pctx) return new Lit("null");

#define GEN_WAITFOR_ANDOR(op, blocks, crf, pctx)  \
  var rv = Dynamic;                               \
  for (var i=0; i<blocks.length; ++i){            \
    rv = rv.seq(blocks[i]);                       \
  }                                               \
  return rv;

#define BEGIN_SUSPEND_BLOCK(pctx) /*nothing*/
#define END_SUSPEND_BLOCK(pctx) /*nothing*/
#define GEN_SUSPEND(has_var, decls, block, crf, pctx)  return block;
#define GEN_COLLAPSE(pctx) /* */
#define GEN_USING(has_var, lhs, exp, body, pctx)  return body;
#define BEGIN___JS_BLOCK(pctx)
#define END___JS_BLOCK(pctx)
#define GEN___JS(body, pctx) return Dynamic;
#define GEN_BLOCKLAMBDA(pars, body, pctx) return Dynamic;


